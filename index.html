<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,Spring,Mybatis,面试,分布式,多线程,数据库,优化,并发,React,Flutter">










<meta name="description" content="网络资源搬运工 Java Spring 面试 数据库 算法 zk dubbo 分布式 redis React Flutter anything">
<meta name="keywords" content="网络资源搬运工 Java Spring 面试 数据库 算法 zk dubbo 分布式 redis React Flutter anything">
<meta property="og:type" content="website">
<meta property="og:title" content="My Blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="My Blogs">
<meta property="og:description" content="网络资源搬运工 Java Spring 面试 数据库 算法 zk dubbo 分布式 redis React Flutter anything">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Blogs">
<meta name="twitter:description" content="网络资源搬运工 Java Spring 面试 数据库 算法 zk dubbo 分布式 redis React Flutter anything">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>My Blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">求知若渴 虚心若愚</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-主页"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-归档"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/25/yuque/为什么阿里巴巴要求谨慎使用ArrayList中的subList方法 - 掘金/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/25/yuque/为什么阿里巴巴要求谨慎使用ArrayList中的subList方法 - 掘金/" itemprop="url">为什么阿里巴巴要求谨慎使用ArrayList中的subList方法 - 掘金</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-25T15:48:15+08:00">
                2019-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer" target="_blank" rel="noopener">GitHub 3.7k Star 的Java工程师成神之路 ，不来了解一下吗?</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer" target="_blank" rel="noopener">GitHub 3.7k Star 的Java工程师成神之路 ，真的不来了解一下吗?</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer" target="_blank" rel="noopener">GitHub 3.7k Star 的Java工程师成神之路 ，真的确定不来了解一下吗?</a></p>
<p>集合是Java开发日常开发中经常会使用到的。在之前的一些文章中，我们介绍过一些关于使用集合类应该注意的事项，如《为什么阿里巴巴禁止在 foreach 循环里进行元素的 remove/add 操作》、《为什么阿里巴巴建议集合初始化时，指定集合容量大小》等。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/06/25/yuque/为什么阿里巴巴要求谨慎使用ArrayList中的subList方法 - 掘金/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/20/yuque/30个mysql千万级大数据SQL查询优化技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/20/yuque/30个mysql千万级大数据SQL查询优化技巧/" itemprop="url">30个mysql千万级大数据SQL查询优化技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-20T23:02:07+08:00">
                2019-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文总结了30个mysql千万级大数据SQL查询优化技巧,特别适合大</p>
<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fs4.51cto.com%2Foss%2F201807%2F30%2F31e83f5bfedbbc6758440150a0337e25.jpeg-wh_651x-s_631009781.jpeg" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2018/8/8/165188676eae5d5f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#align=left&display=inline&height=366&originHeight=366&originWidth=651&status=done&width=651" alt></a></p>
<p>数据里的MYSQL使用。</p>
<p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0</p>
<p>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p>
<p>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num=10 or num=20可以这样查询：select id from t where num=10 union all select id from t where num=20</p>
<p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3</p>
<p>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</p>
<ol start="7">
<li>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：select id from t where num=@num可以改为强制查询使用索引：select id from t with(index(索引名)) where num=<a href>@num </a></li>
</ol>
<p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num/2=100应改为:select id from t where num=100*2</p>
<p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where substring(name,1,3)=’abc’ ，name以abc开头的id应改为:</p>
<p>select id from t where name like ‘abc%’</p>
<p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p>12.不要写一些没有意义的查询，如需要生成一个空表结构：select col1,col2 into #t from t where 1=0</p>
<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p>
<p>create table #t(…)</p>
<p>13.很多时候用 exists 代替 in 是一个好的选择：select num from a where num in(select num from b)</p>
<p>用下面的语句替换：</p>
<p>select num from a where exists(select 1 from b where num=a.num)</p>
<p>14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p>
<ol start="15">
<li><p>索引并不是越多越好，索引固然可 以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p>
</li>
<li><p>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
</li>
</ol>
<p>17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<p>18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>19.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
<p>20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
<p>21.避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
<p>22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p>
<p>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
<p>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
<p>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
<p>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
<ol start="27">
<li>与临时表一样，游标并不是不可使 用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</li>
</ol>
<p>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC 消息。</p>
<p>29.尽量避免大事务操作，提高系统并发能力。</p>
<p>30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<p>如果你的程序都能满足这30条的话那么你的程序执行效率会有很大的提高</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/yuque/MySQL 性能优化神器 Explain 使用分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/yuque/MySQL 性能优化神器 Explain 使用分析/" itemprop="url">MySQL 性能优化神器 Explain 使用分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-21T11:26:05+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href></a><br><a name="e05dce83"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 <code>SELECT</code> 语句进行分析, 并输出 <code>SELECT</code> 执行的详细信息, 以供开发人员针对性优化.<br><br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * from user_info WHERE  id &lt; 300;</span><br></pre></td></tr></table></figure>

<p><a href></a><br><a name="424a2ad8"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user_info` (</span><br><span class="line">  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `age`  INT(11)              DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `name_index` (`name`)</span><br><span class="line">)</span><br><span class="line">  ENGINE = InnoDB</span><br><span class="line">  DEFAULT CHARSET = utf8</span><br><span class="line"></span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `order_info` (</span><br><span class="line">  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_id`      BIGINT(20)           DEFAULT NULL,</span><br><span class="line">  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `productor`    VARCHAR(30)          DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br><span class="line">)</span><br><span class="line">  ENGINE = InnoDB</span><br><span class="line">  DEFAULT CHARSET = utf8</span><br><span class="line"></span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);</span><br></pre></td></tr></table></figure>

<p><a href></a><br><a name="156d011a"></a></p>
<h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><p>EXPLAIN 命令的输出内容大致如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>各列的含义如下:</p>
<ul>
<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>
<li>select_type: SELECT 查询的类型.</li>
<li>table: 查询的是哪个表</li>
<li>partitions: 匹配的分区</li>
<li>type: join 类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引.</li>
<li>ref: 哪个字段或常数与 key 一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
<p>接下来我们来重点看一下比较重要的几个字段.</p>
<p><a name="select_type"></a></p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><code>select_type</code> 表示了查询的类型, 它的常用取值有:</p>
<ul>
<li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li>
<li>PRIMARY, 表示此查询是最外层的查询</li>
<li>UNION, 表示此查询是 UNION 的第二或随后的查询</li>
<li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li>
<li>UNION RESULT, UNION 的结果</li>
<li>SUBQUERY, 子查询中的第一个 SELECT</li>
<li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li>
</ul>
<p>最常见的查询类别应该是 <code>SIMPLE</code> 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 <code>SIMPLE</code> 类型, 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))</span><br><span class="line">    -&gt; UNION</span><br><span class="line">    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));</span><br><span class="line">+</span><br><span class="line">| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+</span><br><span class="line">|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |</span><br><span class="line">|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+</span><br><span class="line">3 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><a name="table"></a></p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p>
<p><a name="type"></a></p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.<br><a href></a><br><a name="63641849"></a></p>
<h4 id="type-常用类型"><a href="#type-常用类型" class="headerlink" title="type 常用类型"></a>type 常用类型</h4><p>type 常用的取值有:</p>
<ul>
<li><code>system</code>: 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</li>
<li><code>const</code>: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br><br>例如下面的这个查询, 它使用了主键索引, 因此 <code>type</code> 就是 <code>const</code> 类型的.<br><br>mysql&gt; explain select * from user_info where id = 2\G<br></li>
</ul>
<p><strong>_ 1. row _</strong><br><br>id: 1<br><br>select_type: SIMPLE<br><br>table: user_info<br><br>partitions: NULL<br><br>type: const<br><br>possible_keys: PRIMARY<br><br>key: PRIMARY<br><br>key_len: 8<br><br>ref: const<br><br>rows: 1<br><br>filtered: 100.00<br><br>Extra: NULL<br><br>1 row in set, 1 warning (0.00 sec)</p>
<ul>
<li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 <code>=</code>, 查询效率较高. 例如:<br><br>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\G<br></li>
</ul>
<p><strong>_ 1. row _</strong><br><br>id: 1<br><br>select_type: SIMPLE<br><br>table: order_info<br><br>partitions: NULL<br><br>type: index<br><br>possible_keys: user_product_detail_index<br><br>key: user_product_detail_index<br><br>key_len: 314<br><br>ref: NULL<br><br>rows: 9<br><br>filtered: 100.00<br><br>Extra: Using where; Using index<br><br><strong>_ 2. row _</strong><br><br>id: 1<br><br>select_type: SIMPLE<br><br>table: user_info<br><br>partitions: NULL<br><br>type: eq_ref<br><br>possible_keys: PRIMARY<br><br>key: PRIMARY<br><br>key_len: 8<br><br>ref: test.order_info.user_id<br><br>rows: 1<br><br>filtered: 100.00<br><br>Extra: NULL<br><br>2 rows in set, 1 warning (0.00 sec)</p>
<ul>
<li><code>ref</code>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询.<br><br>例如下面这个例子中, 就使用到了 <code>ref</code> 类型的查询:<br><br>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\G<br></li>
</ul>
<p><strong>_ 1. row _</strong><br><br>id: 1<br><br>select_type: SIMPLE<br><br>table: user_info<br><br>partitions: NULL<br><br>type: const<br><br>possible_keys: PRIMARY<br><br>key: PRIMARY<br><br>key_len: 8<br><br>ref: const<br><br>rows: 1<br><br>filtered: 100.00<br><br>Extra: NULL<br><br><strong>_ 2. row _</strong><br><br>id: 1<br><br>select_type: SIMPLE<br><br>table: order_info<br><br>partitions: NULL<br><br>type: ref<br><br>possible_keys: user_product_detail_index<br><br>key: user_product_detail_index<br><br>key_len: 9<br><br>ref: const<br><br>rows: 1<br><br>filtered: 100.00<br><br>Extra: Using index<br><br>2 rows in set, 1 warning (0.01 sec)</p>
<ul>
<li><code>range</code>: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br><br>当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个.</li>
</ul>
<p>例如下面的例子就是一个范围查询:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT *</span><br><span class="line">    -&gt;         FROM user_info</span><br><span class="line">    -&gt;         WHERE id BETWEEN 2 AND 8 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>index</code>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br><br><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <code>Using index</code>.</li>
</ul>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: name_index</span><br><span class="line">      key_len: 152</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 10</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 <code>index</code>, 并且 Extra 的值是 <code>Using index</code>.</p>
<ul>
<li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br><br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.<br><br>mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \G<br></li>
</ul>
<p><strong>_ 1. row _</strong><br><br>id: 1<br><br>select_type: SIMPLE<br><br>table: user_info<br><br>partitions: NULL<br><br>type: ALL<br><br>possible_keys: NULL<br><br>key: NULL<br><br>key_len: NULL<br><br>ref: NULL<br><br>rows: 10<br><br>filtered: 10.00<br><br>Extra: Using where<br><br>1 row in set, 1 warning (0.00 sec)</p>
<p><a href></a><br><a name="1c3ee6de"></a></p>
<h4 id="type-类型的性能比较"><a href="#type-类型的性能比较" class="headerlink" title="type 类型的性能比较"></a>type 类型的性能比较</h4><p>通常来说, 不同的 type 类型的性能关系如下:<br><br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br><br><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br><br>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br><br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p>
<p><a name="possible_keys"></a></p>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定.</p>
<p><a name="key"></a></p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p>
<p><a name="key_len"></a></p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br><br>key_len 的计算规则如下:</p>
<ul>
<li>字符串<ul>
<li>char(n): n 字节长度</li>
<li>varchar(n): 如果是 utf8 编码, 则是 3 <em>n + 2字节; 如果是 utf8mb4 编码, 则是 4</em> n + 2 字节.</li>
</ul>
</li>
<li>数值类型:<ul>
<li>TINYINT: 1字节</li>
<li>SMALLINT: 2字节</li>
<li>MEDIUMINT: 3字节</li>
<li>INT: 4字节</li>
<li>BIGINT: 8字节</li>
</ul>
</li>
<li>时间类型<ul>
<li>DATE: 3字节</li>
<li>TIMESTAMP: 4字节</li>
<li>DATETIME: 8字节</li>
</ul>
</li>
<li>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</li>
</ul>
<p>我们来举两个简单的栗子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos; \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 9</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5</span><br><span class="line">     filtered: 11.11</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure>

<p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中, 因为先进行 user_id 的范围查询, 而根据 <code>最左前缀匹配</code> 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code>, 因此在 <code>EXPLAIN</code> 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT &#39;0&#39;</code>, 则 key_length 应该是8.</p>
<p>上面因为 <code>最左前缀匹配</code> 原则, 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段, 因此效率不算高.</p>
<p>接下来我们来看一下下一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &apos;p1&apos; \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 161</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 2</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p>
<p><a name="rows"></a></p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br><br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>
<p><a name="Extra"></a></p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>
<ul>
<li>Using filesort<br><br>当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code>, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li>
</ul>
<p>例如下面的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 253</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 9</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index; Using filesort</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>我们的索引是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure>

<p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 <code>Using filesort</code>.<br><br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code>, 那么就不会出现 <code>Using filesort</code> 了. 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 253</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 9</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>Using index<br><br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>
<li>Using temporary<br><br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/18/yuque/上线之前/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/yuque/上线之前/" itemprop="url">上线之前</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-18T14:04:12+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>入参为空有没有处理</li>
<li>数据库查询为空有没有处理</li>
<li>数据库新增字段有没有提交到审核平台</li>
<li>SQL有没有命中索引</li>
<li>当有新增或是修改的配置时，是否及时同步到了阿波罗</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/yuque/Java动态追踪技术探究 - 美团技术团队/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/yuque/Java动态追踪技术探究 - 美团技术团队/" itemprop="url">Java动态追踪技术探究 - 美团技术团队</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-25T13:50:26+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="47f6f944"></a></p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>在遥远的希艾斯星球爪哇国塞沃城中，两名年轻的程序员正在为一件事情苦恼，程序出问题了，一时看不出问题出在哪里，于是有了以下对话：</p>
<p>“Debug一下吧。”</p>
<p>“线上机器，没开Debug端口。”</p>
<p>“看日志，看看请求值和返回值分别是什么？”</p>
<p>“那段代码没打印日志。”</p>
<p>“改代码，加日志，重新发布一次。”</p>
<p>“怀疑是线程池的问题，重启会破坏现场。”</p>
<p>长达几十秒的沉默之后：“据说，排查问题的最高境界，就是只通过Review代码来发现问题。”</p>
<p>比几十秒长几十倍的沉默之后：“我轮询了那段代码一十七遍之后，终于得出一个结论。”</p>
<p>“结论是？”</p>
<p>“我还没到达只通过Review代码就能发现问题的至高境界。”</p>
<p><a name="46b7b012"></a></p>
<h2 id="从JSP说起"><a href="#从JSP说起" class="headerlink" title="从JSP说起"></a>从JSP说起</h2><p>对于大多数Java程序员来说，早期的时候，都会接触到一个叫做JSP（Java Server Pages）的技术。虽然这种技术，在前后端代码分离、前后端逻辑分离、前后端组织架构分离的今天来看，已经过时了，但是其中还是有一些有意思的东西，值得拿出来说一说。</p>
<p>当时刚刚处于Java入门时期的我们，大多数精力似乎都放在了JSP的页面展示效果上了：</p>
<p>“这个表格显示的行数不对”</p>
<p>“原来是for循环写的有问题，改一下，刷新页面再试一遍”</p>
<p>“嗯，好了，表格显示没问题了，但是，登录人的姓名没取到啊，是不是Sesstion获取有问题？”</p>
<p>“有可能，我再改一下，一会儿再刷新试试”</p>
<p>……</p>
<p>在一遍一遍修改代码刷新浏览器页面重试的时候，我们自己也许并没有注意到一件很酷的事情：我们修改完代码，居然只是简单地刷新一遍浏览器页面，修改就生效了，整个过程并没有重启JVM。按照我们的常识，Java程序一般都是在启动时加载类文件，如果都像JSP这样修改完代码，不用重启就生效的话，那文章开头的问题就可以解决了啊：Java文件中加一段日志打印的代码，不重启就生效，既不破坏现场，又可以定位问题。忍不住试一试：修改、编译、替换class文件。额，不行，新改的代码并没有生效。那为什么偏偏JSP可以呢？让我们先来看看JSP的运行原理。</p>
<p>当我们打开浏览器，请求访问一个JSP文件的时候，整个过程是这样的:</p>
<p><img src="https://p1.meituan.net/travelcube/7fceed5036a40f4bd22ccf86629069c0118151.jpg#align=left&display=inline&height=389&originHeight=782&originWidth=1498&status=done&width=746" alt></p>
<p>JSP文件处理过程</p>
<p>JSP文件修改过后，之所以能及时生效，是因为Web容器（Tomcat）会检查请求的JSP文件是否被更改过。如果发生过更改，那么就将JSP文件重新解析翻译成一个新的Sevlet类，并加载到JVM中。之后的请求，都会由这个新的Servet来处理。<strong>这里有个问题，根据Java的类加载机制，在同一个ClassLoader中，类是不允许重复的。为了绕开这个限制，Web容器每次都会创建一个新的ClassLoader实例，来加载新编译的Servlet类。之后的请求都会由这个新的Servlet来处理，这样就实现了新旧JSP的切换。</strong></p>
<p>HTTP服务是无状态的，所以JSP的场景基本上都是一次性消费，这种通过创建新的ClassLoader来“替换”class的做法行得通，但是对于其他应用，比如Spring框架，即便这样做了，对象多数是单例，对于内存中已经创建好的对象，我们无法通过这种创建新的ClassLoader实例的方法来修改对象行为。</p>
<p>我就是想不重启应用加个日志打印，就这么难吗？</p>
<p><a name="1125ee41"></a></p>
<h2 id="Java对象行为"><a href="#Java对象行为" class="headerlink" title="Java对象行为"></a>Java对象行为</h2><p>既然JSP的办法行不通，那我们来看看还有没有其他的办法。仔细想想，我们会发现，文章开头的问题本质上是动态改变内存中已存在对象的行为的问题。所以，我们得先弄清楚JVM中和对象行为有关的地方在哪里，有没有更改的可能性。</p>
<p>我们都知道，对象使用两种东西来描述事物：行为和属性。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(str);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面Person类中age和name是属性，speak是行为。对象是类的事例，每个对象的属性都属于对象本身，但是每个对象的行为却是公共的。举个例子，比如我们现在基于Person类创建了两个对象，personA和personB：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person personA = <span class="keyword">new</span> Person(<span class="number">43</span>, <span class="string">"lixunhuan"</span>);</span><br><span class="line"></span><br><span class="line">personA.speak(<span class="string">"我是李寻欢"</span>);</span><br><span class="line"></span><br><span class="line">Person personB = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">"afei"</span>);</span><br><span class="line"></span><br><span class="line">personB.speak(<span class="string">"我是阿飞"</span>);</span><br></pre></td></tr></table></figure>

<p>personA和personB有各自的姓名和年龄，但是有共同的行为：speak。想象一下，如果我们是Java语言的设计者，我们会怎么存储对象的行为和属性呢？</p>
<p>“很简单，属性跟着对象走，每个对象都存一份。行为是公共的东西，抽离出来，单独放到一个地方。”</p>
<p>“咦？抽离出公共的部分，跟代码复用好像啊。”</p>
<p>“大道至简，很多东西本来都是殊途同归。”</p>
<p>也就是说，第一步我们首先得找到存储对象行为的这个公共的地方。一番搜索之后，我们发现这样一段描述：</p>
<blockquote>
<p>Method area is created on virtual machine startup, shared among all Java virtual machine threads and it is logically part of heap area. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors.</p>
</blockquote>
<p>Java的对象行为（方法、函数）是存储在方法区的。</p>
<p>“方法区中的数据从哪来？”</p>
<p>“方法区中的数据是类加载时从class文件中提取出来的。”</p>
<p>“class文件从哪来？”</p>
<p>“从Java或者其他符合JVM规范的源代码中编译而来。”</p>
<p>“源代码从哪来？”</p>
<p>“废话，当然是手写！”</p>
<p>“倒着推，手写没问题，编译没问题，至于加载……有没有办法加载一个已经加载过的类呢？如果有的话，我们就能修改字节码中目标方法所在的区域，然后重新加载这个类，这样方法区中的对象行为（方法）就被改变了，而且不改变对象的属性，也不影响已经存在对象的状态，那么就可以搞定这个问题了。可是，这岂不是违背了JVM的类加载原理？毕竟我们不想改变ClassLoader。”</p>
<p>“少年，可以去看看<code>java.lang.instrument.Instrumentation</code>。”</p>
<p><a name="java.lang.instrument.Instrumentation"></a></p>
<h2 id="java-lang-instrument-Instrumentation"><a href="#java-lang-instrument-Instrumentation" class="headerlink" title="java.lang.instrument.Instrumentation"></a>java.lang.instrument.Instrumentation</h2><p>看完文档之后，我们发现这么两个接口：redefineClasses和retransformClasses。一个是重新定义class，一个是修改class。这两个大同小异，看reDefineClasses的说明：</p>
<blockquote>
<p>This method is used to replace the definition of a class without reference to the existing class file bytes, as one might do when recompiling from source for fix-and-continue debugging. Where the existing class file bytes are to be transformed (for example in bytecode instrumentation) retransformClasses should be used.</p>
</blockquote>
<p>都是替换已经存在的class文件，redefineClasses是自己提供字节码文件替换掉已存在的class文件，retransformClasses是在已存在的字节码文件上修改后再替换之。</p>
<p>当然，运行时直接替换类很不安全。比如新的class文件引用了一个不存在的类，或者把某个类的一个field给删除了等等，这些情况都会引发异常。所以如文档中所言，instrument存在诸多的限制：</p>
<blockquote>
<p>The redefinition may change method bodies, the constant pool and attributes. The redefinition must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. These restrictions maybe be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</p>
</blockquote>
<p>我们能做的基本上也就是简单修改方法内的一些行为，这对于我们开头的问题，打印一段日志来说，已经足够了。当然，我们除了通过reTransform来打印日志，还能做很多其他非常有用的事情，这个下文会进行介绍。</p>
<p>那怎么得到我们需要的class文件呢？一个最简单的方法，是把修改后的Java文件重新编译一遍得到class文件，然后调用redefineClasses替换。但是对于没有（或者拿不到，或者不方便修改）源码的文件我们应该怎么办呢？其实对于JVM来说，不管是Java也好，Scala也好，任何一种符合JVM规范的语言的源代码，都可以编译成class文件。JVM的操作对象是class文件，而不是源码。所以，从这种意义上来讲，我们可以说“JVM跟语言无关”。既然如此，不管有没有源码，其实我们只需要修改class文件就行了。</p>
<p><a name="30680ce1"></a></p>
<h2 id="直接操作字节码"><a href="#直接操作字节码" class="headerlink" title="直接操作字节码"></a>直接操作字节码</h2><p>Java是软件开发人员能读懂的语言，class字节码是JVM能读懂的语言，class字节码最终会被JVM解释成机器能读懂的语言。无论哪种语言，都是人创造的。所以，理论上（实际上也确实如此）人能读懂上述任何一种语言，既然能读懂，自然能修改。只要我们愿意，我们完全可以跳过Java编译器，直接写字节码文件，只不过这并不符合时代的发展罢了，毕竟高级语言设计之始就是为我们人类所服务，其开发效率也比机器语言高很多。</p>
<p>对于人类来说，字节码文件的可读性远远没有Java代码高。尽管如此，还是有一些杰出的程序员们创造出了可以用来直接编辑字节码的框架，提供接口可以让我们方便地操作字节码文件，进行注入修改类的方法，动态创造一个新的类等等操作。其中最著名的框架应该就是ASM了，cglib、Spring等框架中对于字节码的操作就建立在ASM之上。</p>
<p>我们都知道，Spring的AOP是基于动态代理实现的，Spring会在运行时动态创建代理类，代理类中引用被代理类，在被代理的方法执行前后进行一些神秘的操作。那么，Spring是怎么在运行时创建代理类的呢？动态代理的美妙之处，就在于我们不必手动为每个需要被代理的类写代理类代码，Spring在运行时会根据需要动态地创造出一个类，这里创造的过程并非通过字符串写Java文件，然后编译成class文件，然后加载。Spring会直接“创造”一个class文件，然后加载，创造class文件的工具，就是ASM了。</p>
<p>到这里，我们知道了用ASM框架直接操作class文件，在类中加一段打印日志的代码，然后调用retransformClasses就可以了。</p>
<p><a name="BTrace"></a></p>
<h2 id="BTrace"><a href="#BTrace" class="headerlink" title="BTrace"></a>BTrace</h2><p>截止到目前，我们都是停留在理论描述的层面。那么如何进行实现呢？先来看几个问题：</p>
<ol>
<li>在我们的工程中，谁来做这个寻找字节码，修改字节码，然后reTransform的动作呢？我们并非先知，不可能知道未来有没有可能遇到文章开头的这种问题。考虑到性价比，我们也不可能在每个工程中都开发一段专门做这些修改字节码、重新加载字节码的代码。</li>
<li>如果JVM不在本地，在远程呢？</li>
<li>如果连ASM都不会用呢？能不能更通用一些，更“傻瓜”一些。</li>
</ol>
<p>幸运的是，因为有BTrace的存在，我们不必自己写一套这样的工具了。什么是BTrace呢？<a href="https://github.com/btraceio/btrace" target="_blank" rel="noopener">BTrace</a>已经开源，项目描述极其简短：</p>
<blockquote>
<p>A safe, dynamic tracing tool for the Java platform.</p>
</blockquote>
<p>BTrace是基于Java语言的一个安全的、可提供动态追踪服务的工具。BTrace基于ASM、Java Attach Api、Instruments开发，为用户提供了很多注解。依靠这些注解，我们可以编写BTrace脚本（简单的Java代码）达到我们想要的效果，而不必深陷于ASM对字节码的操作中不可自拔。</p>
<p>看BTrace官方提供的一个简单例子：拦截所有java.io包中所有类中以read开头的方法，打印类名、方法名和参数名。当程序IO负载比较高的时候，就可以从输出的信息中看到是哪些类所引起，是不是很方便？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.btrace.samples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.AnyType;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@BTrace</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgArray</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnMethod</span>(</span><br><span class="line">        clazz=<span class="string">"/java\\.io\\..*/"</span>,</span><br><span class="line">        method=<span class="string">"/read.*/"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyRead</span><span class="params">(@ProbeClassName String pcn, @ProbeMethodName String pmn, AnyType[] args)</span> </span>&#123;</span><br><span class="line">        println(pcn);</span><br><span class="line">        println(pmn);</span><br><span class="line">        printArray(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看另一个例子：每隔2秒打印截止到当前创建过的线程数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.btrace.samples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.Export;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">@BTrace</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Export</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMethod</span>(</span><br><span class="line">        clazz=<span class="string">"java.lang.Thread"</span>,</span><br><span class="line">        method=<span class="string">"start"</span></span><br><span class="line">    ) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onnewThread</span><span class="params">(@Self Thread t)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnTimer</span>(<span class="number">2000</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ontimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        println(count);</span><br><span class="line">        </span><br><span class="line">        println(Counters.perfLong(<span class="string">"btrace.com.sun.btrace.samples.ThreadCounter.count"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了上面的用法是不是有所启发？忍不住冒出来许多想法。比如查看HashMap什么时候会触发rehash，以及此时容器中有多少元素等等。</p>
<p>有了BTrace，文章开头的问题可以得到完美的解决。至于BTrace具体有哪些功能，脚本怎么写，这些Git上BTrace工程中有大量的说明和举例，网上介绍BTrace用法的文章更是恒河沙数，这里就不再赘述了。</p>
<p>我们明白了原理，又有好用的工具支持，剩下的就是发挥我们的创造力了，只需在合适的场景下合理地进行使用即可。</p>
<p>既然BTrace能解决上面我们提到的所有问题，那么BTrace的架构是怎样的呢？</p>
<p>BTrace主要有下面几个模块：</p>
<ol>
<li>BTrace脚本：利用BTrace定义的注解，我们可以很方便地根据需要进行脚本的开发。</li>
<li>Compiler：将BTrace脚本编译成BTrace class文件。</li>
<li>Client：将class文件发送到Agent。</li>
<li>Agent：基于Java的Attach Api，Agent可以动态附着到一个运行的JVM上，然后开启一个BTrace Server，接收client发过来的BTrace脚本；解析脚本，然后根据脚本中的规则找到要修改的类；修改字节码后，调用Java Instrument的reTransform接口，完成对对象行为的修改并使之生效。</li>
</ol>
<p>整个BTrace的架构大致如下：</p>
<p><img src="https://p1.meituan.net/travelcube/25f19ea854450ce3964d20ae778f621a178594.jpg#align=left&display=inline&height=576&originHeight=1190&originWidth=1542&status=done&width=746" alt></p>
<p>BTrace工作流程</p>
<p>BTrace最终借Instruments实现class的替换。如上文所说，出于安全考虑，Instruments在使用上存在诸多的限制，BTrace也不例外。BTrace对JVM来说是“只读的”，因此BTrace脚本的限制如下：</p>
<ol>
<li>不允许创建对象</li>
<li>不允许创建数组</li>
<li>不允许抛异常</li>
<li>不允许catch异常</li>
<li>不允许随意调用其他对象或者类的方法，只允许调用com.sun.btrace.BTraceUtils中提供的静态方法（一些数据处理和信息输出工具）</li>
<li>不允许改变类的属性</li>
<li>不允许有成员变量和方法，只允许存在<strong>static public void</strong>方法</li>
<li>不允许有内部类、嵌套类</li>
<li>不允许有同步方法和同步块</li>
<li>不允许有循环</li>
<li>不允许随意继承其他类（当然，java.lang.Object除外）</li>
<li>不允许实现接口</li>
<li>不允许使用assert</li>
<li>不允许使用Class对象</li>
</ol>
<p>如此多的限制，其实可以理解。BTrace要做的是，虽然修改了字节码，但是除了输出需要的信息外，对整个程序的正常运行并没有影响。</p>
<p><a name="Arthas"></a></p>
<h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><p>BTrace脚本在使用上有一定的学习成本，如果能把一些常用的功能封装起来，对外直接提供简单的命令即可操作的话，那就再好不过了。阿里的工程师们早已想到这一点，就在去年（2018年9月份），阿里巴巴开源了自己的Java诊断工具——<a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">Arthas</a>。Arthas提供简单的命令行操作，功能强大。究其背后的技术原理，和本文中提到的大致无二。Arthas的文档很全面，想详细了解的话可以戳<a href="https://alibaba.github.io/arthas/" target="_blank" rel="noopener">这里</a>。</p>
<p>本文旨在说明Java动态追踪技术的来龙去脉，掌握技术背后的原理之后，只要愿意，各位读者也可以开发出自己的“冰封王座”出来。</p>
<p><a name="60dbeb74"></a></p>
<h2 id="尾声：三生万物"><a href="#尾声：三生万物" class="headerlink" title="尾声：三生万物"></a>尾声：三生万物</h2><p>现在，让我们试着站在更高的地方“俯瞰”这些问题。</p>
<p>Java的Instruments给运行时的动态追踪留下了希望，Attach API则给运行时动态追踪提供了“出入口”，ASM则大大方便了“人类”操作Java字节码的操作。</p>
<p>基于Instruments和Attach API前辈们创造出了诸如JProfiler、Jvisualvm、BTrace、Arthas这样的工具。以ASM为基础发展出了cglib、动态代理，继而是应用广泛的Spring AOP。</p>
<p>Java是静态语言，运行时不允许改变数据结构。然而，Java 5引入Instruments，Java 6引入Attach API之后，事情开始变得不一样了。虽然存在诸多限制，然而，在前辈们的努力下，仅仅是利用预留的近似于“只读”的这一点点狭小的空间，仍然创造出了各种大放异彩的技术，极大地提高了软件开发人员定位问题的效率。</p>
<p>计算机应该是人类有史以来最伟大的发明之一，从电磁感应磁生电，到高低电压模拟0和1的比特，再到二进制表示出几种基本类型，再到基本类型表示出无穷的对象，最后无穷的对象组合交互模拟现实生活乃至整个宇宙。</p>
<p>两千五百年前，《道德经》有言：“道生一，一生二，二生三，三生万物。”</p>
<p>两千五百年后，计算机的发展过程也大抵如此吧。</p>
<p><a name="fb9bfd82"></a></p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><ul>
<li>高扬，2017年加入美团打车，负责美团打车结算系统的开发。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/18/yuque/Java后端技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/yuque/Java后端技术/" itemprop="url">Java后端技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-18T11:02:56+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Tomcat相关的面试题出场的几率并不高，正式因为如此，很多人忽略了对Tomcat相关技能的掌握，下面这一篇文章最早发布在知识星球，整理了Tomcat相关的系统架构，介绍了Server、Service、Connector、Container之间的关系，各个模块的功能，可以说把这几个掌握住了，Tomcat相关的面试题你就不会有任何问题了！另外，在面试的时候你还要有意识无意识的往Tomcat这个地方引，就比如说常见的Spring MVC的执行流程，一个URL的完整调用链路，这些相关的题目你是可以再往Tomcat处理请求的这个过程去说的！掌握注Tomcat这些技能了，面试官一定会佩服你的！</p>
<p>另外，知识星球已经精心整理了50+的高频面试题，并且每天保证更新！每一个知识点都会由浅入深的讲解，让你知道其一也要知道其二，有兴趣的看一下，希望对你能有帮助！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdYXstpJFpfibrYFW23o1t4svr8W5Chl3uRTJnVajLREneTiaic2K6Fx5IS6wicBTJBFVD5JibVWgs0AAmA/640?wx_fmt=jpeg" alt></p>
<p>学了本节之后你应该明白的是：</p>
<ul>
<li><p>Server、Service、Connector、Container四大组件之间的关系和联系，以及他们的主要功能点；</p>
</li>
<li><p>Tomcat执行的整体架构，请求是如何被一步步处理的；</p>
</li>
<li><p>Engine、Host、Context、Wrapper相关的概念关系；</p>
</li>
<li><p>Container是如何处理请求的；</p>
</li>
<li><p>Tomcat用到的相关设计模式；</p>
</li>
</ul>
<h2 id="一、Tomcat顶层架构"><a href="#一、Tomcat顶层架构" class="headerlink" title="一、Tomcat顶层架构"></a><strong>一、Tomcat顶层架构</strong></h2><p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但是 Tomcat 非常的模块化，找到了 Tomcat最核心的模块，问题才可以游刃而解，了解了Tomcat的整体架构对以后深入了解Tomcat来说至关重要！</p>
<p>先上一张Tomcat的顶层结构图（图A），如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdZlz44rysyrVpFqrW1Yc0eVnmrFvicJUdktDMOjLftibX92hCrVU4l8BeXQddwHSzSjYYo3TGLMx6Bw/640" alt></p>
<p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。</p>
<p>Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p>
<p>1、Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化; </p>
<p>2、Container用于封装和管理Servlet，以及具体处理Request请求；</p>
<p><strong>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，</strong>也可以提供向相同协议不同端口的连接,示意图如下（Engine、Host、Context下边会说到）：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdZlz44rysyrVpFqrW1Yc0eV3liaby3t0N9CLiak7yHAJRLLtfDWzLRhWOlkicav8icmHZZ9vhibibw2SNIw/640" alt></p>
<p><strong>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了</strong>！所以整个 Tomcat 的生命周期由 Server 控制。</p>
<p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的<code>server.xml</code>配置文件中看出，下图是删除了注释内容之后的一个完整的<code>server.xml</code>配置文件（Tomcat版本为8.0）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdZlz44rysyrVpFqrW1Yc0eVkg8tZohjJBocicx6vO5VrJz2eaibfxBDU1qtIAgxZoFNma9LicH961Azg/640" alt></p>
<p>详细的配置文件文件内容可以到Tomcat官网查看：</p>
<p><a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-8.0-doc/index.html</a></p>
<p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdZlz44rysyrVpFqrW1Yc0eVVnWgr1aWBsKCvPibeLWaVm5wAxR4TZJiaEEyRicQsicYyM2SYYwKRsR72Q/640" alt></p>
<p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个，Service左边的内容都属于Container的，Service下边是Connector。</p>
<h2 id="二、Tomcat顶层架构小结："><a href="#二、Tomcat顶层架构小结：" class="headerlink" title="二、Tomcat顶层架构小结："></a><strong>二、Tomcat顶层架构小结：</strong></h2><p>（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；<br>（2） Server掌管着整个Tomcat的生死大权；<br>（4）Service 是对外提供服务的；<br>（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；<br>（6）Container用于封装和管理Servlet，以及具体处理request请求；</p>
<p>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。</p>
<h2 id="三、Connector和Container的微妙关系"><a href="#三、Connector和Container的微妙关系" class="headerlink" title="三、Connector和Container的微妙关系"></a><strong>三、Connector和Container的微妙关系</strong></h2><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p>
<p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p>
<p>Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p>
<h2 id="四、Connector架构分析"><a href="#四、Connector架构分析" class="headerlink" title="四、Connector架构分析"></a><strong>四、Connector架构分析</strong></h2><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p>
<p>因此，我们可以把Connector分为四个方面进行理解：</p>
<p>（1）Connector如何接受请求的？ </p>
<p>（2）如何将请求封装成Request和Response的？ </p>
<p>（3）封装完之后的Request和Response如何交给Container进行处理的？ </p>
<p>（4）Container处理完之后如何交给Connector并返回给客户端的？</p>
<p>首先看一下Connector的结构图（图B），如下所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdZlz44rysyrVpFqrW1Yc0eVeYEclGpQPpq18BPx7z4o731iaXdZHx2ESnC0CgyQEBWia78PbuIOsUtg/640" alt></p>
<p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p>
<p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。</p>
<p>（1）Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。</p>
<p>（2）Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</p>
<p>（3）Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</p>
<p>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p>
<h2 id="五、Container架构分析"><a href="#五、Container架构分析" class="headerlink" title="五、Container架构分析"></a><strong>五、Container架构分析</strong></h2><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下（图C）：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdZlz44rysyrVpFqrW1Yc0eVGIzOn5mxkVBQCQ0FDoBzbpsSUFwCvBpHtDmpBVF087HjnnficUXBjGw/640" alt></p>
<p>4个子容器的作用分别是：</p>
<p>（1）Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine； </p>
<p>（2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点； </p>
<p>（3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件； </p>
<p>（4）Wrapper：每一Wrapper封装着一个Servlet；</p>
<p>下面找一个Tomcat的文件目录对照一下，如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdZlz44rysyrVpFqrW1Yc0eVzG6ScAiaicp62YI1Co6lOgyNVslAibJc7IHNibVib1S4K06D7bmq10icho8A/640" alt></p>
<p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p>
<p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：<a href="http://www.ledouit.com,如果是Host（webapps）下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。" target="_blank" rel="noopener">www.ledouit.com,如果是Host（webapps）下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。</a></p>
<p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p>
<h2 id="六、Container如何处理请求的"><a href="#六、Container如何处理请求的" class="headerlink" title="六、Container如何处理请求的"></a><strong>六、Container如何处理请求的</strong></h2><p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）</p>
<p>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdZlz44rysyrVpFqrW1Yc0eV05rnYJouVYYVYRA1HecPAQq665tNOc8ScURxoGHuFcADkk8SwVhcBA/640" alt></p>
<p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p>
<p>（1）每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的；</p>
<p>（2）在上层容器的管道的BaseValve中会调用下层容器的管道。</p>
<p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。</p>
<p>Pipeline的处理流程图如下（图D）：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbS6ribibqjHPC195DmZX0NBvfyQ2Dk9X4pQiakBQ7XYtDjQwUZpXqRibYzjRmHVRecm4epZW0d7ibITvg/640" alt></p>
<p>（1）Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；</p>
<p>（2）在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</p>
<p>（3）当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！</p>
<p>（4）当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a><strong>七、总结</strong></h2><p>至此，我们已经对Tomcat的整体架构有了大致的了解，从图A、B、C、D可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下Tomcat，上面的内容你能脱口而出吗？当你能够脱口而出的时候，这位面试官一定会对你刮目相看的！</p>
<p><strong>热门内容：</strong>  </p>
<p>1、<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==∣=2247488558&idx=1&sn=4b7b62ea5bb4c08a8735014a8644e077&chksm=e9c5ed9fdeb26489ae527baf9222fbb0126baf466e4a153ffe0f6b772be05a517a0656772f44&scene=21#wechat_redirect" target="_blank" rel="noopener">IDEA一定要懂的30个快捷键！</a></p>
<p>2、<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==∣=2247488553&idx=1&sn=b5802508e51caf332c7e319b59feb8a3&chksm=e9c5ed98deb2648e552b57843b491a6090c4ff6a42eaf44f3108e49b901d9a8d897f47454f1f&scene=21#wechat_redirect" target="_blank" rel="noopener">Dubbo面试18问！这些你都会吗？</a></p>
<p>3、<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==∣=2247488509&idx=1&sn=8be2883dc27168fed77e21c8f6ab4a83&chksm=e9c5ea4cdeb2635a2755709e032d2f9359d3bce7b4dfe61b2e7ba10e934a70905f8c09d8ada9&scene=21#wechat_redirect" target="_blank" rel="noopener">狗屎一样的代码！快，重构我！</a></p>
<p>4、<a href="https://mp.weixin.qq.com/s?__biz=MzUxOTAxODc2Mg==∣=2247484315&idx=1&sn=8887407ad653da90df560ad1187fbb7b&scene=21#wechat_redirect" target="_blank" rel="noopener">2019年超详细的Spring Boot知识清单</a></p>
<p>5、<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==∣=2247488507&idx=1&sn=9a522f7bfdd6d37a156b5cc6f61aa814&chksm=e9c5ea4adeb2635c9f7eabf83fea6f333f6333900d9b9a2bff258a683fea0784d86ccfe17df8&scene=21#wechat_redirect" target="_blank" rel="noopener">你选择25k的996还是18k的965？</a></p>
<p>6、<a href="https://mp.weixin.qq.com/s?__biz=MzUxOTAxODc2Mg==∣=2247484287&idx=1&sn=401829455b5ec966074254f6be083a4e&scene=21#wechat_redirect" target="_blank" rel="noopener">并不是所有的 Github 写在简历上都加分</a></p>
<p>7、<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==∣=2247488502&idx=1&sn=29c9f097027c18192ad3d83ed60bd402&chksm=e9c5ea47deb26351c77a1a503e88cbc8a5bf38318f1d7b6c53ed73c8d6f9879f97d5daaf6ce1&scene=21#wechat_redirect" target="_blank" rel="noopener">你还在 Select * 吗？</a></p>
<p>8、<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==∣=2247488498&idx=1&sn=58a3467469eb8f5f6f24456bf681f592&chksm=e9c5ea43deb263553f2f42f470d97be693d1587b9c9b576183ea5e863e703f896e47f6b9b1e4&scene=21#wechat_redirect" target="_blank" rel="noopener">杭州互联网人的冬天</a></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLda8TWB0rCPDRObrOHuCRKNtndsCNwbsMejpEvEwWTibrcy9xhLbFwbOCarFP5NrZTOZtzGFjeLh6yg/640?" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/yuque/面试官最爱的volatile关键字 - 掘金/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/yuque/面试官最爱的volatile关键字 - 掘金/" itemprop="url">面试官最爱的volatile关键字 - 掘金</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-15T14:19:59+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Java相关的岗位面试中，很多面试官都喜欢考察面试者对Java并发的了解程度，而以<strong>volatile</strong>关键字作为一个小的切入点，往往可以一问到底，把Java内存模型（JMM），Java并发编程的一些特性都牵扯出来，深入地话还可以考察JVM底层实现以及操作系统的相关知识。</p>
<p>下面我们以一次假想的面试过程，来深入了解下volitile关键字吧！</p>
<p><a name="8fd431e9"></a></p>
<h2 id="面试官-Java并发这块了解的怎么样？说说你对volatile关键字的理解"><a href="#面试官-Java并发这块了解的怎么样？说说你对volatile关键字的理解" class="headerlink" title="面试官: Java并发这块了解的怎么样？说说你对volatile关键字的理解"></a>面试官: Java并发这块了解的怎么样？说说你对volatile关键字的理解</h2><p>就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性：</p>
<p>1 . 保证了不同线程对该变量操作的内存可见性;</p>
<p>2 . 禁止指令重排序</p>
<p><a name="94428d3f"></a></p>
<h2 id="面试官-能不能详细说下什么是内存可见性，什么又是重排序呢？"><a href="#面试官-能不能详细说下什么是内存可见性，什么又是重排序呢？" class="headerlink" title="面试官: 能不能详细说下什么是内存可见性，什么又是重排序呢？"></a>面试官: 能不能详细说下什么是内存可见性，什么又是重排序呢？</h2><p>这个聊起来可就多了，我还是从Java内存模型说起吧。</p>
<p>Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。</p>
<p>在Java内存模型里，对上述的优化又进行了一波抽象。JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</p>
<p>这么说得我自己都有些不清楚了，拿张纸画一下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/9/1603a6fae545a200?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#align=left&display=inline&height=439&originHeight=480&originWidth=816&status=done&width=746" alt></p>
<p>在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</p>
<p>使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。比如看下面一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + 1;</span><br></pre></td></tr></table></figure>

<p>假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程1： load i from 主存    // i = 0</span><br><span class="line">        i + 1  // i = 1</span><br><span class="line">线程2： load i from主存  // 因为线程1还没将i的值写回主存，所以i还是0</span><br><span class="line">        i +  1 //i = 1</span><br><span class="line">线程1:  save i to 主存</span><br><span class="line">线程2： save i to 主存</span><br></pre></td></tr></table></figure>

<p>如果两个线程按照上面的执行流程，那么i最后的值居然是1了。如果最后的写回生效的慢，你再读取i的值，都可能是0，这就是缓存不一致问题。</p>
<p>下面就要提到你刚才问到的问题了，JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。</p>
<p><a name="2abbbb2d"></a></p>
<h2 id="面试官：那你具体说说这三个特性呢？"><a href="#面试官：那你具体说说这三个特性呢？" class="headerlink" title="面试官：那你具体说说这三个特性呢？"></a>面试官：那你具体说说这三个特性呢？</h2><p><strong>1 . 原子性(Atomicity)：</strong> Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。 比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 2;</span><br><span class="line">j = i;</span><br><span class="line">i++;</span><br><span class="line">i = i + 1；</span><br></pre></td></tr></table></figure>

<p>上面4个操作中，<code>i=2</code>是读取操作，必定是原子性操作，<code>j=i</code>你以为是原子性操作，其实吧，分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作，<code>i++</code>和<code>i = i + 1</code>其实是等效的，读取i的值，加1，再写回主存，那就是3步操作了。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。</p>
<p>这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。</p>
<p>JMM只实现了基本的原子性，像上面<code>i++</code>那样的操作，必须借助于<code>synchronized</code>和<code>Lock</code>来保证整块代码的原子性了。线程在释放锁之前，必然会把<code>i</code>的值刷回到主存的。</p>
<p><strong>2 . 可见性(Visibility)：</strong></p>
<p>说到可见性，Java就是利用volatile来提供可见性的。 当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。</p>
<p>其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。</p>
<p><strong>3 . 有序性（Ordering）</strong></p>
<p>JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;    //A</span><br><span class="line">double r = 1;        //B</span><br><span class="line">double s= pi * r * r;//C</span><br></pre></td></tr></table></figure>

<p>上面的语句，可以按照<code>A-&gt;B-&gt;C</code>执行，结果为3.14,但是也可以按照<code>B-&gt;A-&gt;C</code>的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。</p>
<p>比如这样的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">    a = 2;              //1</span><br><span class="line">    flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">    if (flag) &#123;         //3</span><br><span class="line">        int ret = a * a;//4</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如有两个线程执行上述代码段，线程1先执行write，随后线程2再执行multiply，最后ret的值一定是4吗？结果不一定：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/9/1603ac14eb04b21e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#align=left&display=inline&height=586&originHeight=586&originWidth=623&status=done&width=623" alt></p>
<p>如图所示，write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。</p>
<p>这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。</p>
<p>另外，JMM具备一些先天的<strong>有序性</strong>,即不需要通过任何手段就可以保证的有序性，通常称为<strong>happens-before</strong>原则。<code>&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;</code>定义了如下happens-before规则：</p>
<blockquote>
<ol>
<li><strong>程序顺序规则</strong>： 一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li><strong>监视器锁规则</strong>：对一个线程的解锁，happens-before于随后对这个线程的加锁</li>
<li><strong>volatile变量规则</strong>： 对一个volatile域的写，happens-before于后续对这个volatile域的读</li>
<li><strong>传递性</strong>：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</li>
<li><strong>start()规则</strong>： 如果线程A执行操作<code>ThreadB_start()</code>(启动线程B) , 那么A线程的<code>ThreadB_start()</code>happens-before 于B中的任意操作</li>
<li><strong>join()原则</strong>： 如果A执行<code>ThreadB.join()</code>并且成功返回，那么线程B中的任意操作happens-before于线程A从<code>ThreadB.join()</code>操作成功返回。</li>
<li><strong>interrupt()原则</strong>： 对线程<code>interrupt()</code>方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过<code>Thread.interrupted()</code>方法检测是否有中断发生</li>
<li><strong>finalize()原则</strong>：一个对象的初始化完成先行发生于它的<code>finalize()</code>方法的开始</li>
</ol>
</blockquote>
<p>第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。</p>
<p>第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。</p>
<p>第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。</p>
<p>第4条规则，就是happens-before的传递性。</p>
<p>后面几条就不再一一赘述了。</p>
<p><a name="c22bb887"></a></p>
<h2 id="面试官：volatile关键字如何满足并发编程的三大特性的？"><a href="#面试官：volatile关键字如何满足并发编程的三大特性的？" class="headerlink" title="面试官：volatile关键字如何满足并发编程的三大特性的？"></a>面试官：volatile关键字如何满足并发编程的三大特性的？</h2><p>那就要重提volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读。 这条再拎出来说，其实就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。</p>
<p>继续拿上面的一段代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">   a = 2;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int ret = a * a;//4</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码不仅仅受到重排序的困扰，即使1、2没有重排序。3也不会那么顺利的执行的。假设还是线程1先执行<code>write</code>操作，线程2再执行<code>multiply</code>操作，由于线程1是在工作内存里把flag赋值为1，不一定立刻写回主存，所以线程2执行时，<code>multiply</code>再从主存读flag值，仍然可能为false，那么括号里的语句将不会执行。</p>
<p>如果改成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">   a = 2;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int ret = a * a;//4</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么线程1先执行<code>write</code>,线程2再执行<code>multiply</code>。根据happens-before原则，这个过程会满足以下3类规则：</p>
<ol>
<li>程序顺序规则：1 happens-before 2; 3 happens-before 4; (volatile限制了指令重排序，所以1 在2 之前执行)</li>
<li>volatile规则：2 happens-before 3</li>
<li>传递性规则：1 happens-before 4</li>
</ol>
<p>从内存语义上来看</p>
<p><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</strong></p>
<p><strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</strong></p>
<p><a name="b45fdb60"></a></p>
<h2 id="面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？"><a href="#面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？" class="headerlink" title="面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？"></a>面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？</h2><p>首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line"> </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。</p>
<p>假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。</p>
<p>线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。</p>
<p>此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。</p>
<p>有人说，<strong>volatile不是会使缓存行无效的吗</strong>？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。</p>
<p>又有人说，线程B将11写回主存，<strong>不会把线程A的缓存行设为无效吗</strong>？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。</p>
<p>综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。</p>
<p>要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。</p>
<p><a name="c71242b4"></a></p>
<h2 id="面试官：说的还可以，那你知道volatile底层的实现机制？"><a href="#面试官：说的还可以，那你知道volatile底层的实现机制？" class="headerlink" title="面试官：说的还可以，那你知道volatile底层的实现机制？"></a>面试官：说的还可以，那你知道volatile底层的实现机制？</h2><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p>
<p>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p>
<blockquote>
<p>1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置<br>2 . 使得本CPU的Cache写入内存<br>3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</p>
</blockquote>
<p><a name="d66555f0"></a></p>
<h2 id="面试官：-你在哪里会使用到volatile，举两个例子呢？"><a href="#面试官：-你在哪里会使用到volatile，举两个例子呢？" class="headerlink" title="面试官： 你在哪里会使用到volatile，举两个例子呢？"></a>面试官： 你在哪里会使用到volatile，举两个例子呢？</h2><ol>
<li>状态量标记，就如上面对flag的标记，我重新提一下：<br><br>int a = 0;<br><br>volatile bool flag = false;<br><br>public void write() {<br><br>a = 2;              //1<br><br>flag = true;        //2<br><br>}
<br>public void multiply() {<br><br>if (flag) {         //3<br><br>int ret = a * a;//4<br><br>}<br><br>}</li>
</ol>
<p>这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。</p>
<p>2.单例模式的实现，典型的双重检查锁定（DCL）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line"> </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance==null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance==null)</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。</p>
<p><a name="b8389362"></a></p>
<h2 id="面试官：-来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？"><a href="#面试官：-来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？" class="headerlink" title="面试官： 来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？"></a>面试官： 来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？</h2><p>好吧，这又是一个话题了，volatile的问题终于问完了。。。看看你掌握了没</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/yuque/实例分析MySQL下的四种事务隔离级别 - 后端 - 掘金/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/yuque/实例分析MySQL下的四种事务隔离级别 - 后端 - 掘金/" itemprop="url">实例分析MySQL下的四种事务隔离级别 - 后端 - 掘金</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-15T09:37:09+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据库事务有四种隔离级别：</p>
<ul>
<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</li>
<li>提交读(Read Committed)：只能读取到已经提交的数据，Oracle等多数数据库默认都是该级别。</li>
<li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。</li>
<li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</li>
</ul>
<p>上面这样的教科书式定义第一次接触事务隔离概念的朋友看了可能会一脸懵逼，下面我们就通过具体的实例来解释四个隔离级别。</p>
<p>首先我们创建一个user表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `name` varchar(255) NOT NULL,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    UNIQUE `uniq_name` USING BTREE (name)</span><br><span class="line">) ENGINE=`InnoDB` AUTO_INCREMENT=10 DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>

<p><a name="815c458e"></a></p>
<h2 id="读未提交隔离级别"><a href="#读未提交隔离级别" class="headerlink" title="读未提交隔离级别"></a>读未提交隔离级别</h2><p>我们先将事务的隔离级别设置为<code>read uncommitted</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.tx_isolation;</span><br><span class="line">+------------------------+</span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+------------------------+</span><br><span class="line">| READ-UNCOMMITTED       |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>在下面我们开了两个终端分别用来模拟事务一和事务二，p.s: 操作一和操作二的意思是按照时间顺序来执行的。</p>
<p><strong>事务1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction; # 操作1</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user(name) values(&apos;ziwenxie&apos;); # 操作3</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br></pre></td></tr></table></figure>

<p><strong>事务2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction; # 操作2</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user; # 操作4</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 10 | ziwenxie |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从上面的执行结果可以和清晰的看出来，在read uncommited级别下面我们在事务一中可能会读取到事务二中没有commit的数据，这就是脏读。</p>
<p><a name="3fdc691d"></a></p>
<h2 id="读提交隔离级别"><a href="#读提交隔离级别" class="headerlink" title="读提交隔离级别"></a>读提交隔离级别</h2><p>通过设置隔离级别为<code>committed</code>可以解决上面的脏读问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read committed;</span><br></pre></td></tr></table></figure>

<p><strong>事务一</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction; # 操作一</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user; # 操作三</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 10 | ziwenxie |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user; # 操作五，操作四的修改并没有影响到事务一</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 10 | ziwenxie |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user; # 操作七</span><br><span class="line"></span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">| 10 | lisi |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit; # 操作八</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>事务二</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction; # 操作二</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update user set name=&apos;lisi&apos; where id=10; # 操作四</span><br><span class="line">Query OK, 1 row affected (0.06 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; commit; # 操作六</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br></pre></td></tr></table></figure>

<p>虽然脏读的问题解决了，但是注意在事务一的操作七中，事务二在操作六commit后会造成事务一在同一个transaction中两次读取到的数据不同，这就是不可重复读问题，使用第三个事务隔离级别repeatable read可以解决这个问题。</p>
<p><a name="4716d740"></a></p>
<h2 id="可重复读隔离级别"><a href="#可重复读隔离级别" class="headerlink" title="可重复读隔离级别"></a>可重复读隔离级别</h2><p>MySQL的Innodb存储引擎默认的事务隔离级别就是可重复读隔离级别，所以我们不用进行多余的设置。</p>
<p><strong>事务一</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start tansactoin; # 操作一</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user; # 操作五</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 10 | ziwenxie |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit; # 操作六</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user; # 操作七</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">| 10 | lisi |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>事务二</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start tansactoin; # 操作二</span><br><span class="line"></span><br><span class="line">mysql&gt; update user set name=&apos;lisi&apos; where id=10; # 操作三</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; commit; # 操作四</span><br></pre></td></tr></table></figure>

<p>在事务一的操作五中我们并没有读取到事务二在操作三中的update，只有在commit之后才能读到更新后的数据。</p>
<p><a name="924b55a7"></a></p>
<h3 id="Innodb解决了幻读么"><a href="#Innodb解决了幻读么" class="headerlink" title="Innodb解决了幻读么"></a>Innodb解决了幻读么</h3><p>实际上RR级别是可能产生幻读，InnoDB引擎官方称中利用MVCC多版本并发控制解决了这个问题，下面我们验证一下Innodb真的解决了幻读了么？</p>
<p>为了方便展示，我修改了一下上面的user表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table user add salary int(11);</span><br><span class="line">Query OK, 0 rows affected (0.51 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; delete from user;</span><br><span class="line">Query OK, 1 rows affected (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user(name, salary) value(&apos;ziwenxie&apos;, 88888888);</span><br><span class="line">Query OK, 1 row affected (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | name     | salary   |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| 10 | ziwenxie | 88888888 |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>事务一</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction;  # 操作一</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user; # 操作三</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | name     | salary   |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| 10 | ziwenxie | 88888888 |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update user set salary=&apos;4444&apos;; # 操作六，竟然影响了两行，不是说解决了幻读么？</span><br><span class="line">Query OK, 2 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 2  Changed: 2  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user; # 操作七， Innodb并没有完全解决幻读</span><br><span class="line">+----+----------+--------+</span><br><span class="line">| id | name     | salary |</span><br><span class="line">+----+----------+--------+</span><br><span class="line">| 10 | ziwenxie |   4444 |</span><br><span class="line">| 11 | zhangsan |   4444 |</span><br><span class="line">+----+----------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit; # 操作八</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br></pre></td></tr></table></figure>

<p><strong>事务二</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction; # 操作二</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user(name, salary) value(&apos;zhangsan&apos;, &apos;666666&apos;); # 操作四</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit; # 操作五</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出，Innodb并没有如官方所说解决幻读，不过上面这样的场景中也不是很常见不用过多的担心。</p>
<p><a name="76a4df16"></a></p>
<h2 id="串行化隔离级别"><a href="#串行化隔离级别" class="headerlink" title="串行化隔离级别"></a>串行化隔离级别</h2><p>所有事务串行执行，最高隔离级别，不会出现幻读性能会很差，实际开发中很少使用到。</p>
<p><a name="2432b575"></a></p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul>
<li>脏读：读到了其他会话还未提交的更新</li>
<li>幻读：读取到其他会话的新增或者删除，侧重于数量的改变</li>
<li>不可重复读：同一个会话中两次执行相同的语句得到的结果不同</li>
</ul>
<p><a name="Contact"></a></p>
<h2 id="Contact"><a href="#Contact" class="headerlink" title="Contact"></a>Contact</h2><p>GitHub: <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fziwenxie" target="_blank" rel="noopener">github.com/ziwenxie</a><br><br>Blog: <a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.ziwenxie.site" target="_blank" rel="noopener">www.ziwenxie.site</a></p>
<blockquote>
<p>本文同步发于我的<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.ziwenxie.site%2F2017%2F08%2F08%2Fmysql-transaction-isolation%2F" target="_blank" rel="noopener">个人博客</a>，转载请声明博客出处 <img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f603.svg#align=left&display=inline&height=18&originHeight=150&originWidth=150&status=done&width=18" alt></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/yuque/MySQL使用可重复读作为默认隔离级别的原因 - vinchen - 博客园/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/yuque/MySQL使用可重复读作为默认隔离级别的原因 - vinchen - 博客园/" itemprop="url">MySQL使用可重复读作为默认隔离级别的原因 - vinchen - 博客园</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-27T14:05:18+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一般的DBMS系统，默认都会使用读提交（Read-Comitted，RC）作为默认隔离级别，如Oracle、SQL Server等，而MySQL却使用可重复读（Read-Repeatable，RR）。要知道，越高的隔离级别，能解决的数据一致性问题越多，理论上性能损耗更大，可并发性越低。隔离级别依次为</p>
<p>SERIALIZABLE &gt; RR &gt; RC &gt; Read-Uncommited</p>
<p>在SQL标准中，前三种隔离级别分别解决了幻象读、不可重复读和脏读的问题。那么，为什么MySQL使用可重复读作为默认隔离级别呢？</p>
<p>Binlog是MySQL的逻辑操作日志，广泛应用于复制和恢复。MySQL 5.1以前，Statement是Binlog的默认格式，即依次记录系统接受的SQL请求；5.1及以后，MySQL提供了Row和Mixed两个Binlog格式。</p>
<p>从MySQL 5.1开始，如果打开语句级Binlog，就不支持RC和Read-Uncommited隔离级别。要想使用RC隔离级别，必须使用Mixed或Row格式。</p>
<p>mysql&gt; set tx_isolation=’read-committed’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; insert into t1 values(1,1);</p>
<p>ERROR 1598 (HY000): Binary logging not possible. Message: Transaction level ‘READ-COMMITTED’ in InnoDB is not safe for binlog mode ‘STATEMENT’</p>
<p>那么，为什么RC隔离级别不支持语句级Binlog呢？我们关闭binlog，做以下测试。</p>
<p>会话1</p>
<p>会话2</p>
<p>use test;</p>
<p>#初始化数据</p>
<p>create table t1(c1 int, c2 int) engine=innodb;</p>
<p>create table t2(c1 int, c2 int) engine=innodb;</p>
<p>insert into t1 values(1,1), (2,2);</p>
<p>insert into t2 values(1,1), (2,2);</p>
<p>#设置隔离级别</p>
<p>set tx_isolation=’read-committed’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>#连续更新两次</p>
<p>mysql&gt; Begin;</p>
<p>Query OK, 0 rows affected (0.03 sec)</p>
<p>mysql&gt; update t2 set c2 = 3 where c1 in (select c1 from t1);</p>
<p>Query OK, 2 rows affected (0.00 sec)</p>
<p>Rows matched: 2  Changed: 2  Warnings: 0</p>
<p>mysql&gt; update t2 set c2 = 4 where c1 in (select c1 from t1);</p>
<p>Query OK, 1 row affected (0.00 sec)</p>
<p>Rows matched: 1  Changed: 1  Warnings: 0</p>
<p>mysql&gt; select * from t2;</p>
<p>+——+——+</p>
<p>| c1   | c2   |</p>
<p>+——+——+</p>
<p>|    1 |    4 |</p>
<p>|    2 |    3 |</p>
<p>+——+——+</p>
<p>2 rows in set (0.00 sec)</p>
<p>mysql&gt; commit;</p>
<p>#设置隔离级别</p>
<p>set tx_isolation=’read-committed’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>#两次更新之间执行删除</p>
<p>mysql&gt; delete from t1 where c1 = 2;</p>
<p>Query OK, 1 row affected (0.03 sec)</p>
<p>由以上测试知，RC隔离级别下，会话2执行时序在会话1事务的语句之间，并且会话2的操作影响了会话1的结果，这会对Binlog结果造成影响。</p>
<p>由于Binlog中语句的顺序以commit为序，如果语句级Binlog允许，两会话的执行时序是</p>
<p>#会话2</p>
<p>set tx_isolation=’read-committed’;</p>
<p>delete from t1 where c1 = 2;</p>
<p>commit;</p>
<p>#会话1</p>
<p>set tx_isolation=’read-committed’;</p>
<p>Begin;</p>
<p>update t2 set c2 = 3 where c1 in (select c1 from t1);</p>
<p>update t2 set c2 = 4 where c1 in (select c1 from t1);</p>
<p>select * from t2;</p>
<p>+——+——+</p>
<p>| c1   | c2   |</p>
<p>+——+——+</p>
<p>|    1 |    4 |</p>
<p>|    2 |    2 |</p>
<p>+——+——+</p>
<p>2 rows in set (0.00 sec)</p>
<p>commit;</p>
<p>由上可知，在MySQL 5.1及以上的RC隔离级别下，语句级Binlog在DR上执行的结果是不正确的！</p>
<p>那么，MySQL 5.0呢？5.0允许RC下语句级Binlog，是不是说很容易产生DB/DR不一致呢？</p>
<p>事实上，在5.0重复上述一个测试，并不存在这个问题，原因是5.0的RC与5.1的RR使用类似的并发和上锁机制，也就是说，MySQL 5.0的RC与5.1及以上的RC可能存在兼容性问题。</p>
<p>下面看看RR是怎么解决这个问题的。</p>
<p>导致RC隔离级别DB/DR不一致的原因是：RC不可重复读，而Binlog要求SQL串行化！</p>
<p>在RR下，重复以上测试</p>
<p>会话1</p>
<p>会话2</p>
<p>use test;</p>
<p>#初始化数据</p>
<p>create table t1(c1 int, c2 int) engine=innodb;</p>
<p>create table t2(c1 int, c2 int) engine=innodb;</p>
<p>insert into t1 values(1,1), (2,2);</p>
<p>insert into t2 values(1,1), (2,2);</p>
<p>#设置隔离级别</p>
<p>set tx_isolation=’repeatable-read’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>#连续更新两次</p>
<p>mysql&gt; Begin;</p>
<p>Query OK, 0 rows affected (0.03 sec)</p>
<p>mysql&gt; update t2 set c2 = 3 where c1 in (select c1 from t1);</p>
<p>Query OK, 2 rows affected (0.00 sec)</p>
<p>Rows matched: 2  Changed: 2  Warnings: 0</p>
<p>mysql&gt; update t2 set c2 = 4 where c1 in (select c1 from t1);</p>
<p>Query OK, 2 rows affected (0.00 sec)</p>
<p>Rows matched: 2  Changed: 2  Warnings: 0</p>
<p>mysql&gt; select * from t2;</p>
<p>+——+——+</p>
<p>| c1   | c2   |</p>
<p>+——+——+</p>
<p>|    1 |    4 |</p>
<p>|    2 |    4 |</p>
<p>+——+——+</p>
<p>2 rows in set (0.00 sec)</p>
<p>mysql&gt; commit;</p>
<p>#设置隔离级别</p>
<p>set tx_isolation=’ repeatable-read’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>#两次更新之间执行删除</p>
<p>mysql&gt; delete from t1 where c1 = 2;</p>
<p>–阻塞，直到会话1提交</p>
<p>Query OK, 1 row affected (18.94 sec)</p>
<p>与RC隔离级别不同的是，在RR中，由于保证可重复读，会话2的delete语句会被会话1阻塞，直到会话1提交。</p>
<p>在RR中，会话1语句update t2 set c2 = 3 where c1 in (select c1 from t1)会先在t1的记录上S锁（5.1的RC中不会上这个锁，但5.0的RC会），接着在t2的满足条件的记录上X锁。由于会话1没提交，会话2的delete语句需要等待会话1的S锁释放，于是阻塞。</p>
<p>因此，在RR中，以上测试会话1、会话2的依次执行，与Binlog的顺序一致，从而保证DB/DR一致。</p>
<p><a name="d5zrtw"></a></p>
<h2 id="幻象读"><a href="#幻象读" class="headerlink" title="幻象读"></a><a href="#d5zrtw"></a>幻象读</h2><p>除了保证可重复读，MySQL的RR还一定程度上避免了幻象读（幻象读是由于插入导致的新记录）。（为什么说一定程度呢？参考第3节可重复读和串行化的区别。）</p>
<p>会话1</p>
<p>会话2</p>
<p>use test;</p>
<p>#初始化数据</p>
<p>create table t1(c1 int primary key, c2 int) engine=innodb;</p>
<p>create table t2(c1 int primary key, c2 int) engine=innodb;</p>
<p>insert into t1 values(1,1), (10,10);</p>
<p>insert into t2 values(1,1), (5,5), (10,10);</p>
<p>#设置隔离级别</p>
<p>set tx_isolation=’repeatable-read’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>#连续更新两次</p>
<p>mysql&gt; Begin;</p>
<p>Query OK, 0 rows affected (0.03 sec)</p>
<p>mysql&gt; update t2 set c2 = 20 where c1 in (select c1 from t1);</p>
<p>Query OK, 2 rows affected (0.00 sec)</p>
<p>Rows matched: 2  Changed: 2  Warnings: 0</p>
<p>mysql&gt; delete from where c1 in (select c1 from t1);</p>
<p>Query OK, 2 rows affected (0.00 sec)</p>
<p>Rows matched: 2  Changed: 2  Warnings: 0</p>
<p>mysql&gt; select * from t2;</p>
<p>+——+——+</p>
<p>| c1   | c2   |</p>
<p>+——+——+</p>
<p>|    5 |    5 |</p>
<p>+——+——+</p>
<p>2 rows in set (0.00 sec)</p>
<p>mysql&gt; commit;</p>
<p>#设置隔离级别</p>
<p>set tx_isolation=’ repeatable-read’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>#两次更新之间执行插入</p>
<p>mysql&gt; insert into t1 values(5,5);</p>
<p>–阻塞，直到会话1提交</p>
<p>Query OK, 1 row affected (18.94 sec)</p>
<p>由上述例子知，会话2的插入操作被阻塞了，原因是RR隔离级别中，除了记录锁外，还会上间隙锁(gap锁)。例如，对于表t1，update t2 set c2 = 20 where c1 in (select c1 from t1)以上的锁包括：</p>
<p>(-∞, 1), 1, (1, 10), 10, (10, +∞)</p>
<p>由于对t1做全表扫描，因此，所有记录和间隙都要上锁，其中(x,y)表示间隙锁，数字表示记录锁，全部都是S锁。会话2的insert操作插入5，位于间隙(1,10)，需要获得这个间隙的X锁，因此两操作互斥，会话2阻塞。</p>
<p>SQL标准的RR并不要求避免幻象读，而InnoDB通过gap锁来避免幻象，从而实现SQL的可串行化，保证Binlog的一致性。</p>
<p>要想取消gap lock，可使用参数<a href="#sysvar_innodb_locks_unsafe_for_binlog">innodb_lock_unsafe_for_binlog</a>=1，默认为0。</p>
<p>InnoDB的RR可以避免不可重复读和幻象读，那么与串行化有什么区别呢？</p>
<p>会话1</p>
<p>会话2</p>
<p>use test;</p>
<p>#初始化数据</p>
<p>create table t3(c1 int primary key, c2 int) engine=innodb;</p>
<p>#设置隔离级别</p>
<p>set tx_isolation=’repeatable-read’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; Begin;</p>
<p>Query OK, 0 rows affected (0.03 sec)</p>
<p>mysql&gt; select * from t3 where c1 = 1;</p>
<p>Empty set (0.00 sec)</p>
<p>mysql&gt; select * from t3 where c1 = 1;</p>
<p>Empty set (0.00 sec)</p>
<p>mysql&gt; update t3 set c2 =2 where c1 = 1;</p>
<p>Query OK, 1 row affected (0.00 sec)</p>
<p>Rows matched: 1  Changed: 1  Warnings: 0</p>
<p>mysql&gt; select * from t3 where c1 = 1;</p>
<p>+—-+——+</p>
<p>| c1 | c2   |</p>
<p>+—-+——+</p>
<p>|  1 |    2 |</p>
<p>+—-+——+</p>
<p>1 row in set (0.00 sec)</p>
<p>mysql&gt; commit;</p>
<p>#设置隔离级别</p>
<p>set tx_isolation=’ repeatable-read’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; insert into t3 values(1,1);</p>
<p>Query OK, 1 row affected (0.05 sec)</p>
<p>由上述会话1中，连续两次读不到数据，但更新却成功，并且更新后的相同读操作就能读到数据了，这算不算幻读呢？</p>
<p>其实，RR隔离级别的防止幻象主要是针对写操作的，即只保证写操作的可串行化，因为只有写操作影响Binlog；而读操作是通过MVCC来保证一致性读（无幻象）。</p>
<p>然而，可串行化隔离级别要求读写可串行化。使用可串行化重做以上测试。</p>
<p>会话1</p>
<p>会话2</p>
<p>use test;</p>
<p>#初始化数据</p>
<p>create table t3(c1 int primary key, c2 int) engine=innodb;</p>
<p>#设置隔离级别</p>
<p>set tx_isolation=’SERIALIZABLE’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; Begin;</p>
<p>Query OK, 0 rows affected (0.03 sec)</p>
<p>mysql&gt; select * from t3 where c1 = 1;</p>
<p>Empty set (0.00 sec)</p>
<p>mysql&gt; select * from t3 where c1 = 1;</p>
<p>Empty set (0.00 sec)</p>
<p>mysql&gt; update t3 set c2 =2 where c1 = 1;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>Rows matched: 0  Changed: 0  Warnings: 0</p>
<p>mysql&gt; select * from t3 where c1 = 1;</p>
<p>Empty set (0.00 sec)</p>
<p>mysql&gt; commit;</p>
<p>#设置隔离级别</p>
<p>set tx_isolation=’SERIALIZABLE’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; insert into t3 values(1,1);</p>
<p>#阻塞，直到会话1提交</p>
<p>Query OK, 1 row affected (48.90 sec)</p>
<p>设置为串行化后，会话2的插入操作被阻塞。由于在串行化下，查询操作不在使用MVCC来保证一致读，而是使用S锁来阻塞其他写操作。因此做到读写可串行化，然而换来就是并发性能的大大降低。</p>
<p>MySQL使用可重复读来作为默认隔离级别的主要原因是语句级的Binlog。RR能提供SQL语句的写可串行化，保证了绝大部分情况（<a href="http://dev.mysql.com/doc/refman/5.1/en/binary-log-mixed.html" target="_blank" rel="noopener">不安全语句</a>除外）的DB/DR一致。</p>
<p>另外，通过这个测试发现MySQL 5.0与5.1在RC下表现是不一样的，可能存在兼容性问题。</p>
<p><a href="http://dev.mysql.com/doc/refman/5.1/en/binary-log-mixed.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.1/en/binary-log-mixed.html</a></p>
<p><a href="http://dev.mysql.com/doc/refman/5.1/en/set-transaction.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.1/en/set-transaction.html</a></p>
<p><a href="http://dev.mysql.com/doc/refman/5.0/en/set-transaction.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.0/en/set-transaction.html</a></p>
<p><a href="http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_locks_unsafe_for_binlog" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_locks_unsafe_for_binlog</a></p>
<p><a href="http://blog.bitfly.cn/post/mysql-innodb-phantom-read/" target="_blank" rel="noopener">http://blog.bitfly.cn/post/mysql-innodb-phantom-read/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/yuque/常用的sql语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/yuque/常用的sql语句/" itemprop="url">常用的sql语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-25T20:16:55+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="5042afb6"></a></p>
<h3 id="交换两列的值"><a href="#交换两列的值" class="headerlink" title="交换两列的值"></a>交换两列的值</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> models_mapping <span class="keyword">as</span> a, models_mapping <span class="keyword">as</span> b </span><br><span class="line"><span class="keyword">set</span> a.souche_model_code=b.third_model_code, a.third_model_code=b.souche_model_code</span><br><span class="line"><span class="keyword">where</span> a.id=b.id <span class="keyword">and</span> a.src_domain=<span class="string">'iautos.cn'</span> <span class="keyword">and</span> a.domain=<span class="string">'souche.com'</span>;</span><br></pre></td></tr></table></figure>

<p><a name="c54edfc1"></a></p>
<h3 id="查询表的所有字段"><a href="#查询表的所有字段" class="headerlink" title="查询表的所有字段"></a>查询表的所有字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">GROUP_CONCAT</span>(<span class="keyword">CONCAT</span>(<span class="string">'\`'</span>,COLUMN_NAME,<span class="string">'\`'</span>)) </span><br><span class="line">	<span class="keyword">from</span> INFORMATION_SCHEMA.Columns </span><br><span class="line">  <span class="keyword">where</span> table_name=<span class="string">'brand'</span> <span class="keyword">and</span> table_schema=<span class="string">'car_model'</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">select</span> COLUMN_NAME,column_comment </span><br><span class="line">	<span class="keyword">from</span> INFORMATION_SCHEMA.Columns </span><br><span class="line">  <span class="keyword">where</span> table_name=<span class="string">'表名'</span> <span class="keyword">and</span> table_schema=<span class="string">'数据库名'</span></span><br></pre></td></tr></table></figure>

<p><a name="14d46fd0"></a></p>
<h3 id="一次新增多个字段"><a href="#一次新增多个字段" class="headerlink" title="一次新增多个字段"></a>一次新增多个字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> models_mapping <span class="keyword">add</span>  (<span class="string">`souche_series_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'来源车系名称'</span>,</span><br><span class="line"><span class="string">`third_brand_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'目的域品牌名称'</span>,</span><br><span class="line"><span class="string">`third_series_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'目的域车系名称'</span>,</span><br><span class="line"><span class="string">`third_model_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'目的域车型名称'</span>);</span><br></pre></td></tr></table></figure>

<p><a name="65b5f47b"></a></p>
<h3 id="复制表数据"><a href="#复制表数据" class="headerlink" title="复制表数据"></a>复制表数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dictionary(<span class="keyword">field</span>,<span class="string">`key`</span>,<span class="string">`value`</span>,date_create,date_update) <span class="keyword">select</span> <span class="keyword">field</span>,dict_key ,<span class="string">`value`</span>,data_create , data_create   <span class="keyword">from</span> config_dictionary ;</span><br></pre></td></tr></table></figure>

<p><a name="tZuU2"></a></p>
<h3 id="新增唯一索引"><a href="#新增唯一索引" class="headerlink" title="新增唯一索引"></a>新增唯一索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">`dictionary`</span> <span class="keyword">add</span> <span class="keyword">UNIQUE</span> uniq_field_value(<span class="string">`field`</span>,<span class="string">`value`</span>);</span><br></pre></td></tr></table></figure>

<p><a name="Ott9l"></a></p>
<h3 id="查询参数价格颜色"><a href="#查询参数价格颜色" class="headerlink" title="查询参数价格颜色"></a>查询参数价格颜色</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">a.model_code <span class="string">'车型编码'</span>,</span><br><span class="line">a.model_name <span class="string">'车型名称'</span>,</span><br><span class="line">a.category_code <span class="string">'车款编码'</span>,</span><br><span class="line">a.category_name <span class="string">'车款名称'</span>,</span><br><span class="line">a.series_code <span class="string">'车系编码'</span>,</span><br><span class="line">a.series_name <span class="string">'车系名称'</span>,</span><br><span class="line">a.brand_code <span class="string">'品牌编码'</span>,</span><br><span class="line">a.brand_name <span class="string">'品牌名称'</span>,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">Group_concat</span>(color_name SEPARATOR <span class="string">','</span>)  <span class="keyword">from</span> model_color <span class="keyword">where</span> model_code = a.model_code <span class="keyword">and</span> <span class="keyword">type</span>=<span class="number">0</span>) <span class="string">'外饰颜色'</span>,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">Group_concat</span>(color_name SEPARATOR <span class="string">','</span>)  <span class="keyword">from</span> model_color <span class="keyword">where</span> model_code = a.model_code <span class="keyword">and</span> <span class="keyword">type</span>=<span class="number">1</span>) <span class="string">'内饰颜色'</span>,</span><br><span class="line">(<span class="keyword">select</span> guide_price  <span class="keyword">from</span> model_price <span class="keyword">where</span> model_code = a.model_code) <span class="string">'指导价'</span>,</span><br><span class="line">(<span class="keyword">select</span> assurance_period_month  <span class="keyword">from</span> model_parameter <span class="keyword">where</span> model_code = a.model_code) <span class="string">'保养周期-月'</span>,</span><br><span class="line">(<span class="keyword">select</span> assurance_period_km  <span class="keyword">from</span> model_parameter <span class="keyword">where</span> model_code = a.model_code) <span class="string">'保养周期-公里'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">model</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> a.model_code <span class="keyword">in</span> </span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">	<span class="keyword">select</span> model_code <span class="keyword">from</span> <span class="keyword">model</span> <span class="keyword">where</span> brand_code <span class="keyword">in</span> (</span><br><span class="line"><span class="string">'brand-74'</span>,<span class="string">'brand-86'</span>,<span class="string">'brand-48'</span></span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><a name="uE6bG"></a></p>
<h3 id="查询车型参数"><a href="#查询车型参数" class="headerlink" title="查询车型参数"></a>查询车型参数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">a.model_code <span class="string">'车型编码'</span>,</span><br><span class="line">a.model_name <span class="string">'车型名称'</span>,</span><br><span class="line">a.category_code <span class="string">'车款编码'</span>,</span><br><span class="line">a.category_name <span class="string">'车款名称'</span>,</span><br><span class="line">a.series_code <span class="string">'车系编码'</span>,</span><br><span class="line">a.series_name <span class="string">'车系名称'</span>,</span><br><span class="line">a.brand_code <span class="string">'品牌编码'</span>,</span><br><span class="line">a.brand_name <span class="string">'品牌名称'</span>,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> dictionary <span class="keyword">where</span> <span class="string">`field`</span>=<span class="string">'fuelForm'</span> <span class="keyword">and</span> <span class="string">`key`</span>=b.fuel_form) <span class="string">'燃料形式'</span>,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> dictionary <span class="keyword">where</span> <span class="string">`field`</span>=<span class="string">'engineVolume'</span> <span class="keyword">and</span> <span class="string">`key`</span>=b.engine_volume) <span class="string">'排量'</span>,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> dictionary <span class="keyword">where</span> <span class="string">`field`</span>=<span class="string">'gearBox'</span> <span class="keyword">and</span> <span class="string">`key`</span>=b.gear_box) <span class="string">'变速'</span>,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> dictionary <span class="keyword">where</span> <span class="string">`field`</span>=<span class="string">'drivingMode'</span> <span class="keyword">and</span> <span class="string">`key`</span>=b.driving_Mode) <span class="string">'驱动方式'</span>,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> dictionary <span class="keyword">where</span> <span class="string">`field`</span>=<span class="string">'intakeType'</span> <span class="keyword">and</span> <span class="string">`key`</span>=b.intake_type) <span class="string">'进气形式'</span>,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> dictionary <span class="keyword">where</span> <span class="string">`field`</span>=<span class="string">'bodyFormId'</span> <span class="keyword">and</span> <span class="string">`key`</span>=b.body_formid) <span class="string">'车身形式标识'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">	<span class="keyword">model</span> a,</span><br><span class="line">	model_parameter b</span><br><span class="line"><span class="keyword">where</span> a.model_code = b.model_code</span><br><span class="line"><span class="keyword">and</span> a.display_tag &amp; <span class="number">4</span>&gt;<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><a name="UmvKp"></a></p>
<h3 id="修改列字段"><a href="#修改列字段" class="headerlink" title="修改列字段"></a>修改列字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> model_parameter <span class="keyword">modify</span> <span class="keyword">column</span> <span class="string">`max_power`</span> <span class="built_in">decimal</span>(<span class="number">6</span>,<span class="number">2</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'最大功率(kW)'</span>;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">临安的风</p>
              <p class="site-description motion-element" itemprop="description">网络资源搬运工 Java Spring 面试 数据库 算法 zk dubbo 分布式 redis React Flutter anything</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">都来自于互联网</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
