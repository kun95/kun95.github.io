<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,Spring,Mybatis,面试,分布式,多线程,数据库,优化,并发,React,Flutter">










<meta name="description" content="网络资源搬运工 Java Spring 面试 数据库 算法 zk dubbo 分布式 redis React Flutter anything">
<meta name="keywords" content="网络资源搬运工 Java Spring 面试 数据库 算法 zk dubbo 分布式 redis React Flutter anything">
<meta property="og:type" content="website">
<meta property="og:title" content="My Blogs">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="My Blogs">
<meta property="og:description" content="网络资源搬运工 Java Spring 面试 数据库 算法 zk dubbo 分布式 redis React Flutter anything">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Blogs">
<meta name="twitter:description" content="网络资源搬运工 Java Spring 面试 数据库 算法 zk dubbo 分布式 redis React Flutter anything">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>My Blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">求知若渴 虚心若愚</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-主页"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-归档"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/05/yuque/批量任务体现多线程的威力！ - 掘金/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/05/yuque/批量任务体现多线程的威力！ - 掘金/" itemprop="url">批量任务体现多线程的威力！ - 掘金</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-05T21:36:12+08:00">
                2019-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于多线程的理解不是非常深刻，工作中用到多线程代码的机会也不多，前不久遇到了一个使用场景，通过编码实现后对于多线程的理解和应用有了更加深刻的理解。场景如下：现有给用户发送产品调研的需求，运营的同事拿来了一个Excel文件，要求给Excel里面大约六万个手机号发送调研短信。</p>
<p>最简单的方法就是一个循环然后单线程顺序发送，但是核心问题在于，给短信运营商发短信的接口响应时间较长，假设平均100ms的响应时间，那么单线程发送的话需要6万*0.1秒=6000秒。显然这个时间是不能接受的，运营商系统的发送接口我们是不能优化的，只得增强自己的发送和处理能力才能尽快的完成任务。</p>
<p><a href></a><br><a name="8ea4e261"></a></p>
<h2 id="读取Excel中的信息"><a href="#读取Excel中的信息" class="headerlink" title="读取Excel中的信息"></a>读取Excel中的信息</h2><p><a href></a><br><a name="dd24a2fa"></a></p>
<h3 id="包依赖"><a href="#包依赖" class="headerlink" title="包依赖"></a>包依赖</h3><p>工具类代码，Maven中引入如下两个包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.xmlbeans&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;xmlbeans&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a href></a><br><a name="306b8a15"></a></p>
<h3 id="读取Excel的工具类代码"><a href="#读取Excel的工具类代码" class="headerlink" title="读取Excel的工具类代码"></a>读取Excel的工具类代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 读取Excel的文件信息</span><br><span class="line"> *</span><br><span class="line"> * @param fileName</span><br><span class="line"> */</span><br><span class="line">public static void readFromExcel(String fileName) &#123;</span><br><span class="line">    InputStream is = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        is = new FileInputStream(fileName);</span><br><span class="line">        XSSFWorkbook workbook = new XSSFWorkbook(is);</span><br><span class="line">        XSSFSheet sheet = workbook.getSheetAt(0);</span><br><span class="line">        int num = 0;</span><br><span class="line">        // 循环行Row</span><br><span class="line">        for (int rowNum = 0, lastNum = sheet.getLastRowNum(); rowNum &lt;= lastNum; rowNum++) &#123;</span><br><span class="line">            XSSFRow row = sheet.getRow(rowNum);</span><br><span class="line">            String phoneNumber = getStringValueFromCell(row.getCell(0)).trim();</span><br><span class="line">            phoneList.add(phoneNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 读取Excel里面Cell内容</span><br><span class="line"> *</span><br><span class="line"> * @param cell</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static String getStringValueFromCell(XSSFCell cell) &#123;</span><br><span class="line"> </span><br><span class="line">    // 单元格内的时间格式</span><br><span class="line">    SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">    // 单元格内的数字类型</span><br><span class="line">    DecimalFormat decimalFormat = new DecimalFormat(&quot;#.#####&quot;);</span><br><span class="line">    // 单元格默认为空</span><br><span class="line">    String cellValue = &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">    if (cell == null) &#123;</span><br><span class="line">        return cellValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 按类型读取</span><br><span class="line">    if (cell.getCellType() == XSSFCell.CELL_TYPE_STRING) &#123;</span><br><span class="line">        cellValue = cell.getStringCellValue();</span><br><span class="line">    &#125; else if (cell.getCellType() == XSSFCell.CELL_TYPE_NUMERIC) &#123;</span><br><span class="line">        // 日期转为时间形式</span><br><span class="line">        if (DateUtil.isCellDateFormatted(cell)) &#123;</span><br><span class="line">            double d = cell.getNumericCellValue();</span><br><span class="line">            Date date = DateUtil.getJavaDate(d);</span><br><span class="line">            cellValue = dateFormat.format(date);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其他转为数字</span><br><span class="line">            cellValue = decimalFormat.format((cell.getNumericCellValue()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (cell.getCellType() == XSSFCell.CELL_TYPE_BLANK) &#123;</span><br><span class="line">        cellValue = &quot;&quot;;</span><br><span class="line">    &#125; else if (cell.getCellType() == XSSFCell.CELL_TYPE_BOOLEAN) &#123;</span><br><span class="line">        cellValue = String.valueOf(cell.getBooleanCellValue());</span><br><span class="line">    &#125; else if (cell.getCellType() == XSSFCell.CELL_TYPE_ERROR) &#123;</span><br><span class="line">        cellValue = &quot;&quot;;</span><br><span class="line">    &#125; else if (cell.getCellType() == XSSFCell.CELL_TYPE_FORMULA) &#123;</span><br><span class="line">        cellValue = cell.getCellFormula().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    return cellValue;</span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a href></a><br><a name="43194329"></a></p>
<h2 id="模拟运营商发送短信的方法"><a href="#模拟运营商发送短信的方法" class="headerlink" title="模拟运营商发送短信的方法"></a>模拟运营商发送短信的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 外部接口耗时长，通过多线程增强</span><br><span class="line"> *</span><br><span class="line"> * @param userPhone</span><br><span class="line"> */</span><br><span class="line">public void sendMsgToPhone(String userPhone) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(SEND_COST_TIME);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;send message to : &quot; + userPhone);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a href></a><br><a name="0d8e4eaa"></a></p>
<h2 id="多线程发短信"><a href="#多线程发短信" class="headerlink" title="多线程发短信"></a>多线程发短信</h2><p><a href></a><br><a name="7d335007"></a></p>
<h3 id="简单的单线程发送"><a href="#简单的单线程发送" class="headerlink" title="简单的单线程发送"></a>简单的单线程发送</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 单线程发送</span><br><span class="line">     *</span><br><span class="line">     * @param phoneList</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private long singleThread(List&lt;String&gt; phoneList) &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        /*// 直接主线程执行</span><br><span class="line">        for (String phoneNumber : phoneList) &#123;</span><br><span class="line">            threadOperation.sendMsgToPhone(phoneNumber);</span><br><span class="line">        &#125;*/</span><br><span class="line">        SendMsgExtendThread smet = threadOperation.new SendMsgExtendThread(phoneList);</span><br><span class="line">        smet.start();</span><br><span class="line">        long totalTime = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(&quot;单线程发送总时间：&quot; + totalTime);</span><br><span class="line">        return totalTime;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对于大批量发短信的场景，如果使用单线程将全部一千个号码发送完毕的话，大约需要103132ms，可见效率低下，耗费时间较长。</p>
<p>多线程发送短信中的一个核心要点是，将全部手机号码拆分成多个组后，分配给每个线程进行执行。</p>
<p><a href></a><br><a name="37cc9449"></a></p>
<h3 id="两个线程的示例"><a href="#两个线程的示例" class="headerlink" title="两个线程的示例"></a>两个线程的示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 两个线程发送</span><br><span class="line"> *</span><br><span class="line"> * @param phoneList</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private long twoThreads(List&lt;String&gt; phoneList) &#123;</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    List&lt;String&gt; list1 = phoneList.subList(0, phoneList.size() / 2);</span><br><span class="line">    List&lt;String&gt; list2 = phoneList.subList(phoneList.size() / 2, phoneList.size());</span><br><span class="line">    SendMsgExtendThread smet = threadOperation.new SendMsgExtendThread(list1);</span><br><span class="line">    smet.start();</span><br><span class="line">    SendMsgExtendThread smet1 = threadOperation.new SendMsgExtendThread(list2);</span><br><span class="line">    smet1.start();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a href></a><br><a name="844e5e8c"></a></p>
<h3 id="另一种数据分组方式"><a href="#另一种数据分组方式" class="headerlink" title="另一种数据分组方式"></a>另一种数据分组方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 另外一种分配方式</span><br><span class="line"> *</span><br><span class="line"> * @param phoneList</span><br><span class="line"> */</span><br><span class="line">private void otherThread(List&lt;String&gt; phoneList) &#123;</span><br><span class="line">    for (int threadNo = 0; threadNo &lt; 10; threadNo++) &#123;</span><br><span class="line">        int numbersPerThread = 10;</span><br><span class="line">        List&lt;String&gt; list = phoneList.subList(threadNo * numbersPerThread, (threadNo * numbersPerThread) + 10);</span><br><span class="line">        SendMsgExtendThread smet = threadOperation.new SendMsgExtendThread(list);</span><br><span class="line">        smet.start();</span><br><span class="line">        if (list.size() &lt; numbersPerThread) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a href></a><br><a name="a476680c"></a></p>
<h3 id="线程池发送"><a href="#线程池发送" class="headerlink" title="线程池发送"></a>线程池发送</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程池发送</span><br><span class="line"> *</span><br><span class="line"> * @param phoneList</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private void threadPool(List&lt;String&gt; phoneList) &#123;</span><br><span class="line">    for (int threadNo = 0; threadNo &lt; THREAD_POOL_SIZE; threadNo++) &#123;</span><br><span class="line">        int numbersPerThread = 10;</span><br><span class="line">        List&lt;String&gt; list = phoneList.subList(threadNo * numbersPerThread, (threadNo * numbersPerThread) + 10);</span><br><span class="line">        threadOperation.executorService.execute(threadOperation.new SendMsgExtendThread(list));</span><br><span class="line">    &#125;</span><br><span class="line">    threadOperation.executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a href></a><br><a name="2c21416f"></a></p>
<h3 id="使用Callable发送"><a href="#使用Callable发送" class="headerlink" title="使用Callable发送"></a>使用Callable发送</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 多线程发送</span><br><span class="line"> *</span><br><span class="line"> * @param phoneList</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private void multiThreadSend(List&lt;String&gt; phoneList) &#123;</span><br><span class="line">    List&lt;Future&lt;Long&gt;&gt; futures = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int threadNo = 0; threadNo &lt; THREAD_POOL_SIZE; threadNo++) &#123;</span><br><span class="line">        int numbersPerThread = 100;</span><br><span class="line">        List&lt;String&gt; list = phoneList.subList(threadNo * numbersPerThread, (threadNo * numbersPerThread) + 100);</span><br><span class="line">        Future&lt;Long&gt; future = threadOperation.executorService.submit(threadOperation.new SendMsgImplCallable(list, String.valueOf(threadNo)));</span><br><span class="line">        futures.add(future);</span><br><span class="line">    &#125;</span><br><span class="line">    for (Future&lt;Long&gt; future : futures) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    threadOperation.executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>使用多线程发送，将发送任务进行分割然后分配给每个线程执行，执行完毕需要10266ms，可见执行效率明显提升，消耗时间明显缩短。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lingyejun.tick.authenticator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.DateUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.XSSFCell;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.XSSFRow;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.XSSFSheet;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.XSSFWorkbook;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadOperation</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 发短信的同步等待时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEND_COST_TIME = <span class="number">100L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 手机号文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILE_NAME = <span class="string">"/Users/lingye/Downloads/phone_number.xlsx"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 手机号列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; phoneList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ThreadOperation threadOperation;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 线程个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始化线程池</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(THREAD_POOL_SIZE, THREAD_POOL_SIZE,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从本地文件中读取手机号码</span></span><br><span class="line">        readFromExcel(FILE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadOperation threadOperation = getInstance();</span><br><span class="line">        <span class="comment">//threadOperation.singleThread(phoneList);</span></span><br><span class="line">        threadOperation.multiThreadSend(phoneList);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例获取对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadOperation <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadOperation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadOperation.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (threadOperation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    threadOperation = <span class="keyword">new</span> ThreadOperation();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadOperation;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取Excel的文件信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFromExcel</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            XSSFWorkbook workbook = <span class="keyword">new</span> XSSFWorkbook(is);</span><br><span class="line">            XSSFSheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 循环行Row</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">0</span>, lastNum = sheet.getLastRowNum(); rowNum &lt;= lastNum; rowNum++) &#123;</span><br><span class="line">                XSSFRow row = sheet.getRow(rowNum);</span><br><span class="line">                String phoneNumber = getStringValueFromCell(row.getCell(<span class="number">0</span>)).trim();</span><br><span class="line">                phoneList.add(phoneNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取Excel里面Cell内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cell</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getStringValueFromCell</span><span class="params">(XSSFCell cell)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 单元格内的时间格式</span></span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        <span class="comment">// 单元格内的数字类型</span></span><br><span class="line">        DecimalFormat decimalFormat = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.#####"</span>);</span><br><span class="line">        <span class="comment">// 单元格默认为空</span></span><br><span class="line">        String cellValue = <span class="string">""</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (cell == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cellValue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 按类型读取</span></span><br><span class="line">        <span class="keyword">if</span> (cell.getCellType() == XSSFCell.CELL_TYPE_STRING) &#123;</span><br><span class="line">            cellValue = cell.getStringCellValue();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cell.getCellType() == XSSFCell.CELL_TYPE_NUMERIC) &#123;</span><br><span class="line">            <span class="comment">// 日期转为时间形式</span></span><br><span class="line">            <span class="keyword">if</span> (DateUtil.isCellDateFormatted(cell)) &#123;</span><br><span class="line">                <span class="keyword">double</span> d = cell.getNumericCellValue();</span><br><span class="line">                Date date = DateUtil.getJavaDate(d);</span><br><span class="line">                cellValue = dateFormat.format(date);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其他转为数字</span></span><br><span class="line">                cellValue = decimalFormat.format((cell.getNumericCellValue()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cell.getCellType() == XSSFCell.CELL_TYPE_BLANK) &#123;</span><br><span class="line">            cellValue = <span class="string">""</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cell.getCellType() == XSSFCell.CELL_TYPE_BOOLEAN) &#123;</span><br><span class="line">            cellValue = String.valueOf(cell.getBooleanCellValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cell.getCellType() == XSSFCell.CELL_TYPE_ERROR) &#123;</span><br><span class="line">            cellValue = <span class="string">""</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cell.getCellType() == XSSFCell.CELL_TYPE_FORMULA) &#123;</span><br><span class="line">            cellValue = cell.getCellFormula().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cellValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部接口耗时长，通过多线程增强</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userPhone</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsgToPhone</span><span class="params">(String userPhone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(SEND_COST_TIME);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"send message to : "</span> + userPhone);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单线程发送</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phoneList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">singleThread</span><span class="params">(List&lt;String&gt; phoneList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">/*// 直接主线程执行</span></span><br><span class="line"><span class="comment">        for (String phoneNumber : phoneList) &#123;</span></span><br><span class="line"><span class="comment">            threadOperation.sendMsgToPhone(phoneNumber);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        SendMsgExtendThread smet = threadOperation.new SendMsgExtendThread(phoneList);</span><br><span class="line">        smet.start();</span><br><span class="line">        <span class="keyword">long</span> totalTime = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">"单线程发送总时间："</span> + totalTime);</span><br><span class="line">        <span class="keyword">return</span> totalTime;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 另外一种分配方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phoneList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">otherThread</span><span class="params">(List&lt;String&gt; phoneList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> threadNo = <span class="number">0</span>; threadNo &lt; <span class="number">10</span>; threadNo++) &#123;</span><br><span class="line">            <span class="keyword">int</span> numbersPerThread = <span class="number">10</span>;</span><br><span class="line">            List&lt;String&gt; list = phoneList.subList(threadNo * numbersPerThread, (threadNo * numbersPerThread) + <span class="number">10</span>);</span><br><span class="line">            SendMsgExtendThread smet = threadOperation.new SendMsgExtendThread(list);</span><br><span class="line">            smet.start();</span><br><span class="line">            <span class="keyword">if</span> (list.size() &lt; numbersPerThread) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个线程发送</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phoneList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">twoThreads</span><span class="params">(List&lt;String&gt; phoneList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; list1 = phoneList.subList(<span class="number">0</span>, phoneList.size() / <span class="number">2</span>);</span><br><span class="line">        List&lt;String&gt; list2 = phoneList.subList(phoneList.size() / <span class="number">2</span>, phoneList.size());</span><br><span class="line">        SendMsgExtendThread smet = threadOperation.new SendMsgExtendThread(list1);</span><br><span class="line">        smet.start();</span><br><span class="line">        SendMsgExtendThread smet1 = threadOperation.new SendMsgExtendThread(list2);</span><br><span class="line">        smet1.start();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池发送</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phoneList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadPool</span><span class="params">(List&lt;String&gt; phoneList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> threadNo = <span class="number">0</span>; threadNo &lt; THREAD_POOL_SIZE; threadNo++) &#123;</span><br><span class="line">            <span class="keyword">int</span> numbersPerThread = <span class="number">10</span>;</span><br><span class="line">            List&lt;String&gt; list = phoneList.subList(threadNo * numbersPerThread, (threadNo * numbersPerThread) + <span class="number">10</span>);</span><br><span class="line">            threadOperation.executorService.execute(threadOperation.new SendMsgExtendThread(list));</span><br><span class="line">        &#125;</span><br><span class="line">        threadOperation.executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程发送</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phoneList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">multiThreadSend</span><span class="params">(List&lt;String&gt; phoneList)</span> </span>&#123;</span><br><span class="line">        List&lt;Future&lt;Long&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> threadNo = <span class="number">0</span>; threadNo &lt; THREAD_POOL_SIZE; threadNo++) &#123;</span><br><span class="line">            <span class="keyword">int</span> numbersPerThread = <span class="number">100</span>;</span><br><span class="line">            List&lt;String&gt; list = phoneList.subList(threadNo * numbersPerThread, (threadNo * numbersPerThread) + <span class="number">100</span>);</span><br><span class="line">            Future&lt;Long&gt; future = threadOperation.executorService.submit(threadOperation.new SendMsgImplCallable(list, String.valueOf(threadNo)));</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Long&gt; future : futures) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(future.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        threadOperation.executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgExtendThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; numberListByThread;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SendMsgExtendThread</span><span class="params">(List&lt;String&gt; numberList)</span> </span>&#123;</span><br><span class="line">            numberListByThread = numberList;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberListByThread.size(); i++) &#123;</span><br><span class="line">                System.out.print(<span class="string">"no."</span> + (i + <span class="number">1</span>));</span><br><span class="line">                sendMsgToPhone(numberListByThread.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"== single thread send "</span> + numberListByThread.size() + <span class="string">"execute time:"</span> + (System.currentTimeMillis() - startTime) + <span class="string">" ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgImplCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; numberListByThread;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> String threadName;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SendMsgImplCallable</span><span class="params">(List&lt;String&gt; numberList, String threadName)</span> </span>&#123;</span><br><span class="line">            numberListByThread = numberList;</span><br><span class="line">            <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Long startMills = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (String number : numberListByThread) &#123;</span><br><span class="line">                sendMsgToPhone(number);</span><br><span class="line">            &#125;</span><br><span class="line">            Long endMills = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">return</span> endMills - startMills;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hahaha</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/24/yuque/Trie 树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/yuque/Trie 树/" itemprop="url">Trie 树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-24T12:45:16+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2013年09月23日 02:14:27 <a href="https://me.csdn.net/arhaiyun" target="_blank" rel="noopener">arhaiyun</a> 阅读数：9467</p>
<p>*<em>Trie 树， *</em>又称字典树，单词查找树。它来源于retrieval(检索)中取中间四个字符构成(读音同try)。用于存储大量的字符串以便支持快速模式匹配。主要应用在信息检索领域。</p>
<p>Trie 有三种结构： 标准trie (standard trie)、压缩trie、<a href="http://hxraid.iteye.com/blog/620414" target="_blank" rel="noopener">后缀trie(suffix trie)</a> 。 最后一种将在<a href="https://www.baidu.com/s?wd=%E3%80%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%864%EF%BC%9A%E5%90%8E%E7%BC%80%E6%A0%91%E3%80%8B&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">《字符串处理4：后缀树》</a>中详细讲，这里只将前两种。</p>
<p><strong>1. 标准Trie (standard trie)</strong></p>
<p>*<em>标准 Trie树的结构 *</em>： 所有含有公共前缀的字符串将挂在树中同一个结点下。实际上trie简明的存储了存在于串集合中的所有公共前缀。 假如有这样一个字符串集合X{bear,bell,bid,bull,buy,sell,stock,stop}。它的标准Trie树如下图：</p>
<p><img src="http://hxraid.iteye.com/upload/picture/pic/57141/51209a0f-3903-36fd-b3b2-19afa62c8cf2.jpg#width=" alt></p>
<p>上图（蓝色圆形结点为内部结点，红色方形结点为外部结点），我们可以很清楚的看到字符串集合X构造的Trie树结构。其中从根结点到红色方框叶子节点所经历的所有字符组成的串就是字符串集合X中的一个串。</p>
<p>注意这里有一个问题： 如果X集合中有一个串是另一个串的前缀呢？ 比如，X集合中加入串bi。那么上图的Trie树在绿色箭头所指的内部结点i 就应该也标记成红色方形结点。这样话，一棵树的枝干上将出现两个连续的叶子结点(这是不合常理的)。</p>
<p>也就是说字符串集合X中不存在一个串是另外一个串的前缀 。如何满足这个要求呢？我们可以在X中的每个串后面加入一个特殊字符$(这个字符将不会出现在字母表中)。这样，集合X{bear$、bell$、…. bi$、bid$}一定会满足这个要求。</p>
<p>总结：一个存储长度为n，来自大小为d的字母表中s个串的集合X的标准trie具有性质如下：</p>
<p>(1) 树中每个内部结点至多有d个子结点。</p>
<p>(2) 树有s个外部结点。</p>
<p>(3) 树的高度等于X中最长串的长度。</p>
<p>(4) 树中的结点数为O(n)。</p>
<p><strong>标准 Trie树的查找</strong></p>
<p>对于英文单词的查找，我们完全可以在内部结点中建立26个元素组成的指针数组。如果要查找a，只需要在内部节点的指针数组中找第0个指针即可(b=第1个指针，随机定位)。时间复杂度为O(1)。</p>
<p>查找过程：假如我们要在上面那棵Trie中查找字符串bull (b-u-l-l)。</p>
<p>(1) 在root结点中查找第(‘b’-‘a’=1)号孩子指针，发现该指针不为空，则定位到第1号孩子结点处——b结点。</p>
<p>(2) 在b结点中查找第(‘u’-‘a’=20)号孩子指针，发现该指针不为空，则定位到第20号孩子结点处——u结点。</p>
<p>(3) … 一直查找到叶子结点出现特殊字符’$’位置，表示找到了bull字符串</p>
<p>如果在查找过程中终止于内部结点，则表示没有找到待查找字符串。</p>
<p>效率：对于有n个英文字母的串来说，在内部结点中定位指针所需要花费O(d)时间，d为字母表的大小，英文为26。由于在上面的算法中内部结点指针定位使用了数组随机存储方式，因此时间复杂度降为了O(1)。但是如果是中文字，下面在实际应用中会提到。因此我们在这里还是用O(d)。 查找成功的时候恰好走了一条从根结点到叶子结点的路径。因此时间复杂度为O(d*n)。</p>
<p>但是，当查找集合X中所有字符串两两都不共享前缀时，trie中出现最坏情况。除根之外，所有内部结点都自由一个子结点。此时的查找时间复杂度蜕化为O(d*(n^2))</p>
<p><strong>标准 Trie树的Java代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">StandarTire.java</span></span><br><span class="line"><span class="comment">Trie 树， 又称字典树，单词查找树。</span></span><br><span class="line"><span class="comment">它来源于retrieval(检索)中取中间四个字符构成(读音同try)。用于存储大量的字符串以便支持快速模式匹配。主要应用在信息检索领域。</span></span><br><span class="line"><span class="comment">@author arhaiyun</span></span><br><span class="line"><span class="comment">date:2013/09/23</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> NodeKind&#123;LN, BN&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Trie node</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> key;</span><br><span class="line">	TrieNode[] points = <span class="keyword">null</span>;</span><br><span class="line">	NodeKind kind = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Branch node</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BranchNode</span> <span class="keyword">extends</span> <span class="title">TrieNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	BranchNode(<span class="keyword">char</span> k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">super</span>.key = k;</span><br><span class="line">		<span class="keyword">super</span>.kind = NodeKind.BN;</span><br><span class="line">		<span class="keyword">super</span>.points = <span class="keyword">new</span> TrieNode[<span class="number">27</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Leaf node</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeafNode</span> <span class="keyword">extends</span> <span class="title">TrieNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	LeafNode(<span class="keyword">char</span> k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">super</span>.key = k;</span><br><span class="line">		<span class="keyword">super</span>.kind = NodeKind.LN;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardTrie</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//Create root node</span></span><br><span class="line">	TrieNode root = <span class="keyword">new</span> BranchNode(<span class="string">' '</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//[1].Insert a word into tire tree</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String words)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		TrieNode curNode = root;</span><br><span class="line">		<span class="comment">//add '$' as an end symbol</span></span><br><span class="line">		words = words + <span class="string">"$"</span>;</span><br><span class="line">		<span class="keyword">char</span>[] chars = words.toCharArray();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(chars[i] == <span class="string">'$'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				curNode.points[<span class="number">26</span>] = <span class="keyword">new</span> LeafNode(<span class="string">'$'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> pSize = chars[i] - <span class="string">'a'</span>;</span><br><span class="line">				<span class="comment">// If not exists creat a new branch node</span></span><br><span class="line">				<span class="keyword">if</span>(curNode.points[pSize] == <span class="keyword">null</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					curNode.points[pSize] = <span class="keyword">new</span> BranchNode(chars[i]);</span><br><span class="line">				&#125;</span><br><span class="line">				curNode = curNode.points[pSize];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//[2].Check if a word is in tire tree</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">fullMatch</span><span class="params">(String words)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		TrieNode curNode = root;</span><br><span class="line">		<span class="keyword">char</span>[] chars = words.toCharArray();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> pSize = chars[i] - <span class="string">'a'</span>;</span><br><span class="line">			System.out.print(chars[i]+<span class="string">"-&gt;"</span>);</span><br><span class="line">			<span class="keyword">if</span>(curNode.points[pSize] == <span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			curNode = curNode.points[pSize];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(curNode.points[<span class="number">26</span>] != <span class="keyword">null</span> &amp;&amp; curNode.points[<span class="number">26</span>].key == <span class="string">'$'</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//[3].preorder root traverse</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorderTraverse</span><span class="params">(TrieNode curNode)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(curNode != <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(curNode.key);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(curNode.kind == NodeKind.BN)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(TrieNode node : curNode.points)</span><br><span class="line">				&#123;</span><br><span class="line">					preorderTraverse(node);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//[4].Get root node</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TrieNode <span class="title">getRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		StandardTrie trie = <span class="keyword">new</span> StandardTrie();</span><br><span class="line">		</span><br><span class="line">		trie.insert(<span class="string">"amazon"</span>);</span><br><span class="line">		trie.insert(<span class="string">"yahoo"</span>);</span><br><span class="line">		trie.insert(<span class="string">"haiyun"</span>);</span><br><span class="line">		trie.insert(<span class="string">"baidu"</span>);</span><br><span class="line">		trie.insert(<span class="string">"alibaba"</span>);</span><br><span class="line">		trie.insert(<span class="string">"offer"</span>);</span><br><span class="line">		trie.insert(<span class="string">"stock"</span>);</span><br><span class="line">		trie.insert(<span class="string">"stop"</span>);</span><br><span class="line">		</span><br><span class="line">		trie.preorderTraverse(trie.getRoot());</span><br><span class="line">		</span><br><span class="line">		System.out.println(trie.fullMatch(<span class="string">"yahoo"</span>));</span><br><span class="line">		System.out.println(trie.fullMatch(<span class="string">"yaho"</span>));</span><br><span class="line">		System.out.println(trie.fullMatch(<span class="string">"baidu"</span>));</span><br><span class="line">		System.out.println(trie.fullMatch(<span class="string">"alibaba"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/yuque/Java 泛型总结（三）：通配符的使用 - Coding - SegmentFault 思否/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/yuque/Java 泛型总结（三）：通配符的使用 - Coding - SegmentFault 思否/" itemprop="url">Java 泛型总结（三）：通配符的使用 - Coding - SegmentFault 思否</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-22T12:57:08+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前两篇文章介绍了泛型的基本用法、类型擦除以及泛型数组。在泛型的使用中，还有个重要的东西叫通配符，本文介绍通配符的使用。</p>
<p>这个系列的另外两篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000005179142" target="_blank" rel="noopener">Java 泛型总结（一）：基本用法与类型擦除</a></li>
<li><a href="https://segmentfault.com/a/1190000005179147" target="_blank" rel="noopener">Java 泛型总结（二）：泛型与数组</a></li>
</ul>
<h2 id="数组的协变"><a href="#数组的协变" class="headerlink" title="数组的协变"></a>数组的协变</h2><p>在了解通配符之前，先来了解一下数组。Java 中的数组是<strong>协变</strong>的，什么意思？看下面的例子：</p>
<pre><code>class Fruit {}
class Apple extends Fruit {}
class Jonathan extends Apple {}
class Orange extends Fruit {}

public class CovariantArrays {
    public static void main(String[] args) {       
        Fruit[] fruit = new Apple[10];
        fruit[0] = new Apple(); 
        fruit[1] = new Jonathan(); 

        try {

            fruit[0] = new Fruit(); 
        } catch(Exception e) { System.out.println(e); }
        try {

            fruit[0] = new Orange(); 
        } catch(Exception e) { System.out.println(e); }
        }
} </code></pre><p><code>main</code> 方法中的第一行，创建了一个 <code>Apple</code> 数组并把它赋给 <code>Fruit</code> 数组的引用。这是有意义的，<code>Apple</code> 是 <code>Fruit</code> 的子类，一个 <code>Apple</code> 对象也是一种 <code>Fruit</code> 对象，所以一个 <code>Apple</code> 数组也是一种 <code>Fruit</code> 的数组。这称作<strong>数组的协变</strong>，Java 把数组设计为协变的，对此是有争议的，有人认为这是一种缺陷。</p>
<p>尽管 <code>Apple[]</code> 可以 “向上转型” 为 <code>Fruit[]</code>，但数组元素的实际类型还是 <code>Apple</code>，我们只能向数组中放入 <code>Apple</code>或者 <code>Apple</code> 的子类。在上面的代码中，向数组中放入了 <code>Fruit</code> 对象和 <code>Orange</code> 对象。对于编译器来说，这是可以通过编译的，但是在运行时期，JVM 能够知道数组的实际类型是 <code>Apple[]</code>，所以当其它对象加入数组的时候就会抛出异常。</p>
<p>泛型设计的目的之一是要使这种运行时期的错误在编译期就能发现，看看用泛型容器类来代替数组会发生什么：</p>
<pre><code>ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;Apple&gt;();</code></pre><p>上面的代码根本就无法编译。当涉及到泛型时， 尽管 <code>Apple</code> 是 <code>Fruit</code> 的子类型，但是 <code>ArrayList&lt;Apple&gt;</code> 不是 <code>ArrayList&lt;Fruit&gt;</code> 的子类型，泛型不支持协变。</p>
<h2 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h2><p>从上面我们知道，<code>List&lt;Number&gt; list = ArrayList&lt;Integer&gt;</code> 这样的语句是无法通过编译的，尽管 <code>Integer</code> 是 <code>Number</code> 的子类型。那么如果我们确实需要建立这种 “向上转型” 的关系怎么办呢？这就需要通配符来发挥作用了。</p>
<h3 id="上边界限定通配符"><a href="#上边界限定通配符" class="headerlink" title="上边界限定通配符"></a>上边界限定通配符</h3><p>利用 <code>&lt;? extends Fruit&gt;</code> 形式的通配符，可以实现泛型的向上转型：</p>
<pre><code>public class GenericsAndCovariance {
    public static void main(String[] args) {

        List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;();




        flist.add(null); 

        Fruit f = flist.get(0);
    }
}</code></pre><p>上面的例子中， <code>flist</code> 的类型是 <code>List&lt;? extends Fruit&gt;</code>，我们可以把它读作：一个类型的 List， 这个类型可以是继承了 <code>Fruit</code> 的某种类型。注意，<strong>这并不是说这个 List 可以持有</strong> <code>Fruit</code> <strong>的任意类型</strong>。通配符代表了一种特定的类型，它表示 “某种特定的类型，但是 <code>flist</code> 没有指定”。这样不太好理解，具体针对这个例子解释就是，<code>flist</code> 引用可以指向某个类型的 List，只要这个类型继承自 <code>Fruit</code>，可以是 <code>Fruit</code> 或者 <code>Apple</code>，比如例子中的 <code>new ArrayList&lt;Apple&gt;</code>，但是为了向上转型给 <code>flist</code>，<code>flist</code> 并不关心这个具体类型是什么。</p>
<p>如上所述，通配符 <code>List&lt;? extends Fruit&gt;</code> 表示某种特定类型 ( <code>Fruit</code> 或者其子类 ) 的 List，但是并不关心这个实际的类型到底是什么，反正是 <code>Fruit</code> 的子类型，<code>Fruit</code> 是它的上边界。那么对这样的一个 List 我们能做什么呢？其实如果我们不知道这个 List 到底持有什么类型，怎么可能安全的添加一个对象呢？在上面的代码中，向 <code>flist</code> 中添加任何对象，无论是 <code>Apple</code> 还是 <code>Orange</code> 甚至是 <code>Fruit</code> 对象，编译器都不允许，唯一可以添加的是 <code>null</code>。所以如果做了泛型的向上转型 (<code>List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;()</code>)，那么我们也就失去了向这个 List 添加任何对象的能力，即使是 <code>Object</code> 也不行。</p>
<p>另一方面，如果调用某个返回 <code>Fruit</code> 的方法，这是安全的。因为我们知道，在这个 List 中，不管它实际的类型到底是什么，但肯定能转型为 <code>Fruit</code>，所以编译器允许返回 <code>Fruit</code>。</p>
<p>了解了通配符的作用和限制后，好像任何接受参数的方法我们都不能调用了。其实倒也不是，看下面的例子：</p>
<pre><code>public class CompilerIntelligence {
    public static void main(String[] args) {
        List&lt;? extends Fruit&gt; flist =
        Arrays.asList(new Apple());
        Apple a = (Apple)flist.get(0); 
        flist.contains(new Apple()); 
        flist.indexOf(new Apple()); 



    }
}</code></pre><p>在上面的例子中，<code>flist</code> 的类型是 <code>List&lt;? extends Fruit&gt;</code>，泛型参数使用了受限制的通配符，所以我们失去了向其中加入任何类型对象的例子，最后一行代码无法编译。</p>
<p>但是 <code>flist</code> 却可以调用 <code>contains</code> 和 <code>indexOf</code> 方法，它们都接受了一个 <code>Apple</code> 对象做参数。如果查看 <code>ArrayList</code> 的源代码，可以发现 <code>add()</code> 接受一个泛型类型作为参数，但是 <code>contains</code> 和 <code>indexOf</code> 接受一个 <code>Object</code> 类型的参数，下面是它们的方法签名：</p>
<pre><code>public boolean add(E e)
public boolean contains(Object o)
public int indexOf(Object o)</code></pre><p>所以如果我们指定泛型参数为 <code>&lt;? extends Fruit&gt;</code> 时，<code>add()</code> 方法的参数变为 <code>? extends Fruit</code>，编译器无法判断这个参数接受的到底是 <code>Fruit</code> 的哪种类型，所以它不会接受任何类型。</p>
<p>然而，<code>contains</code> 和 <code>indexOf</code> 的类型是 <code>Object</code>，并没有涉及到通配符，所以编译器允许调用这两个方法。这意味着一切取决于泛型类的编写者来决定那些调用是 “安全” 的，并且用 <code>Object</code> 作为这些安全方法的参数。如果某些方法不允许类型参数是通配符时的调用，这些方法的参数应该用类型参数，比如 <code>add(E e)</code>。</p>
<p>当我们自己编写泛型类时，上面介绍的就有用了。下面编写一个 <code>Holder</code> 类：</p>
<pre><code>public class Holder&lt;T&gt; {
    private T value;
    public Holder() {}
    public Holder(T val) { value = val; }
    public void set(T val) { value = val; }
    public T get() { return value; }
    public boolean equals(Object obj) {
    return value.equals(obj);
    }
    public static void main(String[] args) {
        Holder&lt;Apple&gt; Apple = new Holder&lt;Apple&gt;(new Apple());
        Apple d = Apple.get();
        Apple.set(d);

        Holder&lt;? extends Fruit&gt; fruit = Apple; 
        Fruit p = fruit.get();
        d = (Apple)fruit.get(); 
        try {
            Orange c = (Orange)fruit.get(); 
        } catch(Exception e) { System.out.println(e); }


        System.out.println(fruit.equals(d)); 
    }
} </code></pre><p>在 <code>Holer</code> 类中，<code>set()</code> 方法接受类型参数 <code>T</code> 的对象作为参数，<code>get()</code> 返回一个 <code>T</code> 类型，而 <code>equals()</code> 接受一个 <code>Object</code> 作为参数。<code>fruit</code> 的类型是 <code>Holder&lt;? extends Fruit&gt;</code>，所以<code>set()</code>方法不会接受任何对象的添加，但是 <code>equals()</code> 可以正常工作。</p>
<h3 id="下边界限定通配符"><a href="#下边界限定通配符" class="headerlink" title="下边界限定通配符"></a>下边界限定通配符</h3><p>通配符的另一个方向是　“超类型的通配符“: <code>? super T</code>，<code>T</code> 是类型参数的下界。使用这种形式的通配符，我们就可以 ”传递对象” 了。还是用例子解释：</p>
<pre><code>public class SuperTypeWildcards {
    static void writeTo(List&lt;? super Apple&gt; apples) {
        apples.add(new Apple());
        apples.add(new Jonathan());

    }
}</code></pre><p><code>writeTo</code> 方法的参数 <code>apples</code> 的类型是 <code>List&lt;? super Apple&gt;</code>，它表示某种类型的 List，这个类型是 <code>Apple</code> 的基类型。也就是说，我们不知道实际类型是什么，但是这个类型肯定是 <code>Apple</code> 的父类型。因此，我们可以知道向这个 List 添加一个 <code>Apple</code> 或者其子类型的对象是安全的，这些对象都可以向上转型为 <code>Apple</code>。但是我们不知道加入 <code>Fruit</code> 对象是否安全，因为那样会使得这个 List 添加跟 <code>Apple</code> 无关的类型。</p>
<p>在了解了子类型边界和超类型边界之后，我们就可以知道如何向泛型类型中 “写入” ( 传递对象给方法参数) 以及如何从泛型类型中 “读取” ( 从方法中返回对象 )。下面是一个例子：</p>
<pre><code>public class Collections { 
  public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) 
  {
      for (int i=0; i&lt;src.size(); i++) 
        dest.set(i,src.get(i)); 
  } 
}</code></pre><p><code>src</code> 是原始数据的 List，因为要从这里面读取数据，所以用了上边界限定通配符：<code>&lt;? extends T&gt;</code>，取出的元素转型为 <code>T</code>。<code>dest</code> 是要写入的目标 List，所以用了下边界限定通配符：<code>&lt;? super T&gt;</code>，可以写入的元素类型是 <code>T</code> 及其子类型。</p>
<h3 id="无边界通配符"><a href="#无边界通配符" class="headerlink" title="无边界通配符"></a>无边界通配符</h3><p>还有一种通配符是无边界通配符，它的使用形式是一个单独的问号：<code>List&lt;?&gt;</code>，也就是没有任何限定。不做任何限制，跟不用类型参数的 <code>List</code> 有什么区别呢？</p>
<p><code>List&lt;?&gt; list</code> 表示 <code>list</code> 是持有某种特定类型的 List，但是不知道具体是哪种类型。那么我们可以向其中添加对象吗？当然不可以，因为并不知道实际是哪种类型，所以不能添加任何类型，这是不安全的。而单独的 <code>List list</code> ，也就是没有传入泛型参数，表示这个 list 持有的元素的类型是 <code>Object</code>，因此可以添加任何类型的对象，只不过编译器会有警告信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通配符的使用可以对泛型参数做出某些限制，使代码更安全，对于上边界和下边界限定的通配符总结如下：</p>
<ul>
<li>使用 <code>List&lt;? extends C&gt; list</code> 这种形式，表示 list 可以引用一个 <code>ArrayList</code> ( 或者其它 List 的 子类 ) 的对象，这个对象包含的元素类型是 <code>C</code> 的子类型 ( 包含 <code>C</code> 本身）的一种。</li>
<li>使用 <code>List&lt;? super C&gt; list</code> 这种形式，表示 list 可以引用一个 <code>ArrayList</code> ( 或者其它 List 的 子类 ) 的对象，这个对象包含的元素就类型是 <code>C</code> 的超类型 ( 包含 <code>C</code> 本身 ) 的一种。</li>
</ul>
<p>大多数情况下泛型的使用比较简单，但是如果自己编写支持泛型的代码需要对泛型有深入的了解。这几篇文章介绍了泛型的基本用法、类型擦除、泛型数组以及通配符的使用，涵盖了最常用的要点，泛型的总结就写到这里。</p>
<p><strong>参考</strong></p>
<ul>
<li>Java 编程思想</li>
</ul>
<p><strong><em>如果我的文章对您有帮助，不妨点个赞支持一下(^\</em>^)_</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/yuque/Java 泛型总结（一）：基本用法与类型擦除 - Coding - SegmentFault 思否/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/yuque/Java 泛型总结（一）：基本用法与类型擦除 - Coding - SegmentFault 思否/" itemprop="url">Java 泛型总结（一）：基本用法与类型擦除 - Coding - SegmentFault 思否</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-22T12:56:27+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="y1fsyh"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><a href="#y1fsyh"></a>简介</h2><p>Java 在 1.5 引入了泛型机制，泛型本质是参数化类型，也就是说变量的类型是一个参数，在使用时再指定为具体类型。泛型可以用于类、接口、方法，通过使用泛型可以使代码更简单、安全。然而 Java 中的泛型使用了类型擦除，所以只是伪泛型。这篇文章对泛型的使用以及存在的问题做个总结，主要参考自 《Java 编程思想》。</p>
<p>这个系列的另外两篇文章：</p>
<ul>
<li><p><a href="https://segmentfault.com/a/1190000005179147" target="_blank" rel="noopener">Java 泛型总结（二）：泛型与数组</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000005337789" target="_blank" rel="noopener">Java 泛型总结（三）：通配符的使用</a></p>
</li>
</ul>
<p><a name="rp66wu"></a></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><a href="#rp66wu"></a>基本用法</h2><p><a name="3kpkow"></a></p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><a href="#3kpkow"></a>泛型类</h3><p>如果有一个类 <code>Holder</code> 用于包装一个变量，这个变量的类型可能是任意的，怎么编写 <code>Holder</code> 呢？在没有泛型之前可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder1</span><span class="params">(Object a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder1 holder1 = <span class="keyword">new</span> Holder1(<span class="string">"not Generic"</span>);</span><br><span class="line">        String s = (String) holder1.get();</span><br><span class="line">        holder1.set(<span class="number">1</span>);</span><br><span class="line">        Integer x = (Integer) holder1.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;j</span><br></pre></td></tr></table></figure>

<p>在 <code>Holder1</code> 中，有一个用 <code>Object</code> 引用的变量。因为任何类型都可以向上转型为 <code>Object</code>，所以这个 <code>Holder</code> 可以接受任何类型。在取出的时候 <code>Holder</code> 只知道它保存的是一个 <code>Object</code> 对象，所以要强制转换为对应的类型。在 <code>main</code> 方法中， <code>holder1</code> 先是保存了一个字符串，也就是 <code>String</code> 对象，接着又变为保存一个 <code>Integer</code> 对象(参数 <code>1</code> 会自动装箱)。从 <code>Holder</code> 中取出变量时强制转换已经比较麻烦，这里还要记住不同的类型，要是转错了就会出现运行时异常。</p>
<p>下面看看 <code>Holder</code> 的泛型版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder2</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder2&lt;String&gt; holder2 = <span class="keyword">new</span> Holder2&lt;&gt;(<span class="string">"Generic"</span>);</span><br><span class="line">        String s = holder2.get();</span><br><span class="line"></span><br><span class="line">        holder2.set(<span class="string">"test"</span>);</span><br><span class="line">        holder2.set(<span class="number">1</span>); <span class="comment">// 编译不通过</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Holder2</code> 中， 变量 <code>a</code> 是一个参数化类型 <code>T</code>，T`` 只是一个标识，用其它字母也是可以的。创建 <code>Holder2</code> 对象的时候，在尖括号中传入了参数 <code>T</code> 的类型，那么在这个对象中，所有出现 <code>T</code> 的地方相当于都用 <code>String</code> 替换了。现在的 <code>get</code> 的取出来的不是 <code>Object</code> ，而是 <code>String</code> 对象，因此不需要类型转换。另外，当调用 <code>set</code> 时，只能传入 <code>String</code> 类型，否则编译无法通过。这就保证了 <code>holder2</code> 中的类型安全，避免由于不小心传入错误的类型。</p>
<p>通过上面的例子可以看出泛使得代码更简便、安全。引入泛型之后，Java 库的一些类，比如常用的容器类也被改写为支持泛型，我们使用的时候都会传入参数类型，如：<code>ArrayList&lt;Integer&gt; list = ArrayList&lt;&gt;();</code>。</p>
<p><a name="1fk2uo"></a></p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a><a href="#1fk2uo"></a>泛型方法</h3><p>泛型不仅可以针对类，还可以单独使某个方法是泛型的，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果在参数中使用了泛型，那么在函数的签名上要用尖括号表现出泛型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(K k,V v)</span> </span>&#123;</span><br><span class="line">        System.out.println(k.getClass().getSimpleName());</span><br><span class="line">        System.out.println(v.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethod gm = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">        gm.f(<span class="keyword">new</span> Integer(<span class="number">0</span>),<span class="keyword">new</span> String(<span class="string">"generic"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">    Integer</span><br><span class="line">    String</span><br></pre></td></tr></table></figure>

<p><code>GenericMethod</code> 类本身不是泛型的，创建它的对象的时候不需要传入泛型参数，但是它的方法 <code>f</code> 是泛型方法。在返回类型之前是它的参数标识 <code>&lt;K,V&gt;</code>，注意这里有两个泛型参数，所以泛型参数可以有多个。</p>
<p>调用泛型方法时可以不显式传入泛型参数，上面的调用就没有。这是因为编译器会使用参数类型推断，根据传入的实参的类型 (这里是 <code>integer</code> 和 <code>String</code>) 推断出 <code>K</code> 和 <code>V</code> 的类型。</p>
<p><a name="ffqotm"></a></p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a><a href="#ffqotm"></a>类型擦除</h2><p><a name="e4r1ku"></a></p>
<h3 id="什么是类型擦除"><a href="#什么是类型擦除" class="headerlink" title="什么是类型擦除"></a><a href="#e4r1ku"></a>什么是类型擦除</h3><p>Java 的泛型使用了类型擦除机制，这个引来了很大的争议，以至于 Java 的泛型功能受到限制，只能说是”伪泛型“。什么叫类型擦除呢？简单的说就是，类型参数只存在于编译期，在运行时，Java 的虚拟机 ( JVM ) 并不知道泛型的存在。先看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码有两个不同的 <code>ArrayList</code>：<code>ArrayList&lt;Integer&gt;</code> 和 <code>ArrayList&lt;String&gt;</code>。在我们看来它们的参数化类型不同，一个保存整性，一个保存字符串。但是通过比较它们的 <code>Class</code> 对象，上面的代码输出是 <code>true</code>。这说明在 JVM 看来它们是同一个类。而在 C++、C# 这些支持真泛型的语言中，它们就是不同的类。</p>
<p>泛型参数会擦除到它的第一个边界，比如说上面的 <code>Holder2</code> 类，参数类型是一个单独的 <code>T</code>，那么就擦除到 <code>Object</code>,相当于所有出现 <code>T</code> 的地方都用 <code>Object</code> 替换。所以在 JVM 看来，保存的变量 <code>a</code> 还是 <code>Object</code> 类型。之所以取出来自动就是我们传入的参数类型，这是因为编译器在编译生成的字节码文件中插入了类型转换的代码，不需要我们手动转型了。如果参数类型有边界那么就擦除到它的第一个边界，这个下一节再说。<br>简而言之：在代码层面，虽有泛型的存在，但是在运行时候的jvm层面却感受不到泛型的存在</p>
<p><a name="gkovvz"></a></p>
<h3 id="擦除带来的问题"><a href="#擦除带来的问题" class="headerlink" title="擦除带来的问题"></a><a href="#gkovvz"></a>擦除带来的问题</h3><p>擦除会出现一些问题，下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HasF.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manipulator</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HasF hasF  = <span class="keyword">new</span> HasF();</span><br><span class="line">        Manipulator&lt;HasF&gt; manipulator = <span class="keyword">new</span> Manipulator&lt;&gt;(hasF);</span><br><span class="line">        manipulator.manipulate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 <code>Manipulator</code> 是一个泛型类，内部用一个泛型化的变量 <code>obj</code>，在 <code>manipulate</code> 方法中，调用了 <code>obj</code> 的方法 <code>f()</code>，但是这行代码无法编译。因为类型擦除，编译器不确定 <code>obj</code> 是否有 <code>f()</code> 方法。解决这个问题的方法是给 <code>T</code> 一个边界:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manipulator2</span><span class="params">(T x)</span> </span>&#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 <code>T</code> 的类型是 <code>&lt;T extends HasF&gt;</code>，这表示 T<code>必须是 HasF</code> 或者 HasF`` 的导出类型。这样，调用 <code>f()</code> 方法才安全。<code>HasF</code> 就是 <code>T</code> 的边界，因此通过类型擦除后，所有出现 <code>T</code> 的<br>地方都用 <code>HasF</code> 替换。这样编译器就知道 <code>obj</code> 是有方法 <code>f()</code> 的。</p>
<p>但是这样就抵消了泛型带来的好处，上面的类完全可以改成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HasF obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manipulator3</span><span class="params">(HasF x)</span> </span>&#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以泛型只有在比较复杂的类中才体现出作用。但是像 <code>&lt;T extends HasF&gt;</code> 这种形式的东西不是完全没有意义的。如果类中有一个返回 <code>T</code> 类型的方法，泛型就有用了，因为这样会返回准确类型。比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnGenericType</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnGenericType</span><span class="params">(T x)</span> </span>&#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> obj; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>get()</code> 方法返回的是泛型参数的准确类型，而不是 <code>HasF</code>。</p>
<p><a name="i1rmga"></a></p>
<h3 id="类型擦除的补偿"><a href="#类型擦除的补偿" class="headerlink" title="类型擦除的补偿"></a><a href="#i1rmga"></a>类型擦除的补偿</h3><p>类型擦除导致泛型丧失了一些功能，任何在运行期需要知道确切类型的代码都无法工作。比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> T) &#123;&#125; </span><br><span class="line">        T <span class="keyword">var</span> = <span class="keyword">new</span> T(); </span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE]; </span><br><span class="line">        T[] array = (T)<span class="keyword">new</span> Object[SIZE]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>new T()</code> 创建对象是不行的，一是由于类型擦除，二是由于编译器不知道 <code>T</code> 是否有默认的构造器。一种解决的办法是传递一个工厂对象并且通过它创建新的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FactoryI</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory) &#123;</span><br><span class="line">        x = factory.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Widget</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Integer&gt;(<span class="keyword">new</span> IntegerFactory());</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Widget&gt;(<span class="keyword">new</span> Widget.Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种解决的方法是利用模板设计模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line">    GenericWithCreate() &#123; element = create(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> X(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Creator c = <span class="keyword">new</span> Creator();</span><br><span class="line">        c.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体类型的创建放到了子类继承父类时，在 <code>create</code> 方法中创建实际的类型并返回。</p>
<p><a name="elwdex"></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#elwdex"></a>总结</h2><p>本文介绍了 Java 泛型的使用，以及类型擦除相关的问题。一般情况下泛型的使用比较简单，但是某些情况下，尤其是自己编写使用泛型的类或者方法时要注意类型擦除的问题。接下来会介绍数组与泛型的关系以及通配符的使用，有兴趣的读者可进入下一篇：<a href="https://segmentfault.com/a/1190000005179147" target="_blank" rel="noopener">Java 泛型总结（二）：泛型与数组</a>。</p>
<p><strong>参考</strong></p>
<ul>
<li>Java 编程思想</li>
</ul>
<p><strong><em>如果我的文章对您有帮助，不妨点个赞支持一下(____)</em></strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/yuque/Linux下五种IO模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/yuque/Linux下五种IO模型/" itemprop="url">Linux下五种IO模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-22T11:35:36+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Linux(UNIX)操作系统中，共有五种IO模型，分别是：<br><strong>阻塞IO模型</strong>非阻塞IO模型<strong>IO复用模型</strong>信号驱动IO模型<strong>异步IO模型</strong>。</p>
<p><a name="ae5a94ab"></a></p>
<h3 id="到底什么是IO"><a href="#到底什么是IO" class="headerlink" title="到底什么是IO"></a>到底什么是IO</h3><p>我们常说的IO，指的是文件的输入和输出，但是在操作系统层面是如何定义IO的呢？到底什么样的过程可以叫做是一次IO呢？<br>拿一次磁盘文件读取为例，我们要读取的文件是存储在磁盘上的，我们的目的是把它读取到内存中。可以把这个步骤简化成把数据从硬件（硬盘）中读取到用户空间中。<br>其实真正的文件读取还涉及到缓存等细节，这里就不展开讲述了。关于用户空间、内核空间以及硬件等的关系如果读者不理解的话，可以通过钓鱼的例子理解。<br>钓鱼的时候，刚开始鱼是在鱼塘里面的，我们的钓鱼动作的最终结束标志是鱼从鱼塘中被我们钓上来，放入鱼篓中。<br>这里面的鱼塘就可以映射成磁盘，中间过渡的鱼钩可以映射成内核空间，最终放鱼的鱼篓可以映射成用户空间。一次完整的钓鱼（IO）操作，是鱼（文件）从鱼塘（硬盘）中转移（拷贝）到鱼篓（用户空间）的过程。</p>
<p><a name="0f2858c7"></a></p>
<h3 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h3><p>我们钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。<br>映射到Linux操作系统中，这就是一种最简单的IO模型，即阻塞IO。 阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。</p>
<p>应用进程通过系统调用 <code>recvfrom</code> 接收数据，但由于内核还未准备好数据报，应用进程就会阻塞住，直到内核准备好数据报，<code>recvfrom</code> 完成数据报复制工作，应用进程才能结束阻塞状态。<br>这种钓鱼方式相对来说比较简单，对于钓鱼的人来说，不需要什么特制的鱼竿，拿一根够长的木棍就可以悠闲的开始钓鱼了（实现简单）。缺点就是比较耗费时间，比较适合那种对鱼的需求量小的情况（并发低，时效性要求低）。<br><img src="https://cdn.nlark.com/yuque/18/2019/png/160921/1547631050178-3fbc6593-9829-4ed5-9644-7683df9b22a0.png#align=left&display=inline&height=305&linkTarget=_blank&name=image.png&originHeight=338&originWidth=621&size=58684&width=561#alt=image.png" alt="image.png"></p>
<p><a name="4090cb84"></a></p>
<h3 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h3><p>我们钓鱼的时候，在等待鱼儿咬钩的过程中，我们可以做点别的事情，比如玩一把王者荣耀、看一集《延禧攻略》等等。但是，我们要时不时的去看一下鱼竿，一旦发现有鱼儿上钩了，就把鱼钓上来。<br>映射到Linux操作系统中，这就是非阻塞的IO模型。应用进程与内核交互，目的未达到之前，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据准备有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中。</p>
<p>应用进程通过 <code>recvfrom</code> 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回<code>error</code>，应用进程在得到<code>error</code>后，过一段时间再发送<code>recvfrom</code>请求。在两次发送请求的时间段，进程可以先做别的事情。<br>这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。<br><img src="https://cdn.nlark.com/yuque/18/2019/png/160921/1547631026635-a675f09e-b8cd-426e-8b72-01b69e7066b0.png#align=left&display=inline&height=312&linkTarget=_blank&name=image.png&originHeight=374&originWidth=702&size=101545&width=585#alt=image.png" alt="image.png"></p>
<p><a name="6b7a84da"></a></p>
<h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。<br>映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。</p>
<p>应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。<br>这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。<br><img src="https://cdn.nlark.com/yuque/18/2019/png/160921/1547631002027-13f3fa45-c8a8-485c-8331-0d3d633eedc0.png#align=left&display=inline&height=320&linkTarget=_blank&name=image.png&originHeight=391&originWidth=710&size=85909&width=579#alt=image.png" alt="image.png"></p>
<p><a name="ba83054e"></a></p>
<h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。<br>映射到Linux操作系统中，这就是IO复用模型。多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。</p>
<p>IO多路转接是多了一个<code>select</code>函数，多个进程的IO可以注册到同一个<code>select</code>上，当用户进程调用该<code>select</code>，<code>select</code>会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，<code>select</code>调用进程会阻塞。当任意一个IO所需的数据准备好之后，<code>select</code>调用就会返回，然后进程在通过<code>recvfrom</code>来进行数据拷贝。<br><strong>这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的。</strong>进程在发出<code>select</code>后，要等到<code>select</code>监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。<br>这种方式的钓鱼，通过增加鱼竿的方式，可以有效的提升效率。<br><img src="https://cdn.nlark.com/yuque/18/2019/png/160921/1547630980222-495b3752-9566-4785-8ef3-d299ec1ae72c.png#align=left&display=inline&height=302&linkTarget=_blank&name=image.png&originHeight=373&originWidth=710&size=103126&width=573#alt=image.png" alt="image.png"></p>
<p><a name="cce95bbd"></a></p>
<h3 id="为什么以上四种都是同步的"><a href="#为什么以上四种都是同步的" class="headerlink" title="为什么以上四种都是同步的"></a>为什么以上四种都是同步的</h3><p>我们说阻塞IO模型、非阻塞IO模型、IO复用模型和信号驱动IO模型都是同步的IO模型。原因是因为，无论以上那种模型，真正的数据拷贝过程，都是同步进行的。<br><strong>信号驱动难道不是异步的么？</strong> 信号驱动，内核是在数据准备好之后通知进程，然后进程再通过<code>recvfrom</code>操作进行数据拷贝。我们可以认为数据准备阶段是异步的，但是，数据拷贝操作是同步的。所以，整个IO过程也不能认为是异步的。</p>
<p>我们把钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据拷贝）。无论以上提到的哪种钓鱼方式，在第二步，都是需要人主动去做的，并不是鱼竿自己完成的。所以，这个钓鱼过程其实还是同步进行的。<br></p>
<p>烧水的报警器一响，整个烧水过程就完成了。水已经是开水了。<br>钓鱼的报警器一响，只能说明鱼儿已经咬钩了，但是还没有真正的钓上来。</p>
<p>所以 ，使用带有报警器的水壶烧水，烧水过程是异步的。<br>而使用带有报警器的鱼竿钓鱼，钓鱼的过程还是同步的。</p>
<p><a name="7fc2d09a"></a></p>
<h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。<br>映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。</p>
<p>用户进程发起<code>aio_read</code>操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到<code>aio_read</code>后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户控件，然后再通知进程本次IO已经完成。<br>这种方式的钓鱼，无疑是最省事儿的。啥都不需要管，只需要交给鱼竿就可以了。<br><img src="https://cdn.nlark.com/yuque/18/2019/png/160921/1547630948762-d55b7c4d-5d9d-456f-83b1-71e1f221a3f6.png#align=left&display=inline&height=335&linkTarget=_blank&name=image.png&originHeight=420&originWidth=697&size=70068&width=556#alt=image.png" alt="image.png"></p>
<p><a name="bef5c8b5"></a></p>
<h3 id="5种IO模型对比"><a href="#5种IO模型对比" class="headerlink" title="5种IO模型对比"></a>5种IO模型对比</h3><p><img src="https://cdn.nlark.com/yuque/18/2019/png/160921/1547630915753-b20ea786-09a3-4f5c-a91f-77fabf109343.png#align=left&display=inline&height=271&linkTarget=_blank&name=image.png&originHeight=541&originWidth=1080&size=199212&width=540#alt=image.png" alt="image.png"></p>
<p>作者：漫话编程_公众号mhcoding<br>链接：<a href="https://juejin.im/post/5b94e93b5188255c672e901e" target="_blank" rel="noopener">https://juejin.im/post/5b94e93b5188255c672e901e</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/yuque/同步、异步、阻塞、非阻塞/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/yuque/同步、异步、阻塞、非阻塞/" itemprop="url">同步、异步、阻塞、非阻塞</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-22T11:34:51+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="c69714e1"></a></p>
<h3 id="什么是同步和异步"><a href="#什么是同步和异步" class="headerlink" title="什么是同步和异步"></a>什么是同步和异步</h3><p>说到烧水，我们都是通过热水壶来烧水的。在很久之前，科技还没有这么发达的时候，如果我们要烧水，需要把水壶放到火炉上，我们通过观察水壶内的水的沸腾程度来判断水有没有烧开。<br>随着科技的发展，现在市面上的水壶都有了提醒功能，当我们把水壶插电之后，水壶水烧开之后会通过声音提醒我们水开了。<br>对于烧水这件事儿来说，传统水壶的烧水就是同步的，高科技水壶的烧水就是异步的。<br><strong>同步请求</strong>，A调用B，B的处理是同步的，在处理完之前他不会通知A，只有处理完之后才会明确的通知A。<br><strong>异步请求</strong>，A调用B，B的处理是异步的，B在接到请求后先告诉A我已经接到请求了，然后异步去处理，处理完之后通过回调等方式再通知A。<br>所以说，同步和异步最大的区别就是被调用方的执行方式和返回时机。同步指的是被调用方做完事情之后再返回，异步指的是被调用方先返回，然后再做事情，做完之后再想办法通知调用方。</p>
<p><a name="03d51ecf"></a></p>
<h3 id="什么是阻塞和非阻塞"><a href="#什么是阻塞和非阻塞" class="headerlink" title="什么是阻塞和非阻塞"></a>什么是阻塞和非阻塞</h3><p>还是那个烧水的例子，当你把水放到水壶里面，按下开关后，你可以坐在水壶前面，别的事情什么都不做，一直等着水烧好。你还可以先去客厅看电视，等着水开就好了。<br>对于你来说，坐在水壶前面等就是阻塞的，去客厅看电视等着水开就是非阻塞的。<br><strong>阻塞请求</strong>，A调用B，A一直等着B的返回，别的事情什么也不干。<br><strong>非阻塞请求</strong>，A调用B，A不用一直等着B的返回，先去忙别的事情了。<br>所以说，阻塞和非阻塞最大的区别就是在被调用方返回结果之前的这段时间内，调用方是否一直等待。阻塞指的是调用方一直等待别的事情什么都不做。非阻塞指的是调用方先去忙别的事情。</p>
<p><a name="31012f88"></a></p>
<h3 id="阻塞、非阻塞和同步、异步的区别"><a href="#阻塞、非阻塞和同步、异步的区别" class="headerlink" title="阻塞、非阻塞和同步、异步的区别"></a>阻塞、非阻塞和同步、异步的区别</h3><p>首先，前面已经提到过，阻塞、非阻塞和同步、异步其实针对的对象是不一样的。<strong>阻塞、非阻塞说的是调用者，同步、异步说的是被调用者</strong>。<br>有人认为阻塞和同步是一回事儿，非阻塞和异步是一回事。但是这是不对的。<br><strong>先来看同步场景中是如何包含阻塞和非阻塞情况的。</strong><br>我们是用传统的水壶烧水。在水烧开之前我们一直做在水壶前面，等着水开。这就是阻塞的。<br>我们是用传统的水壶烧水。在水烧开之前我们先去客厅看电视了，但是水壶不会主动通知我们，需要我们时不时的去厨房看一下水有没有烧开。这就是非阻塞的。<br><strong>再来看异步场景中是如何包含阻塞和非阻塞情况的。</strong><br>我们是用带有提醒功能的水壶烧水。在水烧发出提醒之前我们一直做在水壶前面，等着水开。这就是阻塞的。<br>我们是用带有提醒功能的水壶烧水。在水烧发出提醒之前我们先去客厅看电视了，等水壶发出声音提醒我们。这就是非阻塞的。</p>
<p><a name="c3160154"></a></p>
<h3 id="Java中的三种IO模型"><a href="#Java中的三种IO模型" class="headerlink" title="Java中的三种IO模型"></a>Java中的三种IO模型</h3><p>在Java语言中，一共提供了三种IO模型，分别是阻塞IO（BIO）、非阻塞IO（NIO）、异步IO（AIO）。<br>这里面的BIO和NIO都是同步的IO模型，即同步阻塞IO和同步非阻塞IO，异步IO指的是异步非阻塞IO。<br><strong>BIO （Blocking I/O）</strong>：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。<br><strong>NIO （New I/O）</strong>：同时支持阻塞与非阻塞模式，但主要是使用同步非阻塞IO。<br><strong>AIO （Asynchronous I/O）</strong>：异步非阻塞I/O模型。</p>
<p>作者：漫话编程_公众号mhcoding<br>链接：<a href="https://juejin.im/post/5b94e2995188255c5c45d0ec" target="_blank" rel="noopener">https://juejin.im/post/5b94e2995188255c5c45d0ec</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/yuque/BAT 经典算法笔试题 —— 磁盘多路归并排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/yuque/BAT 经典算法笔试题 —— 磁盘多路归并排序/" itemprop="url">BAT 经典算法笔试题 —— 磁盘多路归并排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-22T11:34:01+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.im/post/5c3fe473f265da615c5980de" target="_blank" rel="noopener">https://juejin.im/post/5c3fe473f265da615c5980de</a></p>
</blockquote>
<p>在 LevelDB 数据库中高层数据下沉到低层时需要经历一次 Major Compaction，将高层文件的有序键值对和低层文件的多个有序键值对进行归并排序。磁盘多路归并排序算法的输入是来自多个磁盘文件的有序键值对，在内存中将这些文件的键值对进行排序，然后输出到一到多个新的磁盘文件中。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685994296d730e0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#alt=#alt=" alt></p>
<p>多路归并排序在大数据领域也是常用的算法，常用于海量数据排序。当数据量特别大时，这些数据无法被单个机器内存容纳，它需要被切分位多个集合分别由不同的机器进行内存排序（map 过程），然后再进行多路归并算法将来自多个不同机器的数据进行排序（reduce 过程），这是流式多路归并排序，为什么说是流式排序呢，因为数据源来源于网络套接字。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/17/16859942908a6035?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#alt=#alt=" alt></p>
<p>多路归并排序的优势在于内存消耗极低，它的内存占用和输入文件的数量成正比，和数据总量无关，数据总量只会线性正比影响排序的时间。</p>
<p>下面我们来亲自实现一下磁盘多路归并算法，为什么是磁盘，因为它的输入来自磁盘文件。</p>
<p><a name="71add235"></a></p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>我们需要在内存里维护一个有序数组。每个输入文件当前最小的元素作为一个元素放在数组里。数组按照元素的大小保持排序状态。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685994285919537?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#alt=#alt=" alt></p>
<p>接下来我们开始进入循环，循环的逻辑总是从最小的元素下手，在其所在的文件取出下一个元素，和当前数组中的元素进行比较。根据比较结果进行不同的处理，这里我们使用二分查找算法进行快速比较。注意每个输入文件里面的元素都是有序的。</p>
<ol>
<li>如果取出来的元素和当前数组中的最小元素相等，那么就可以直接将这个元素输出。再继续下一轮循环。不可能取出比当前数组最小元素还要小的元素，因为输入文件本身也是有序的。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/17/168599428a394d82?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#alt=#alt=" alt></p>
<ol>
<li>否则就需要将元素插入到当前的数组中的指定位置，继续保持数组有序。然后将数组中当前最小的元素输出并移除。再进行下一轮循环。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685994286796823?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#alt=#alt=" alt> 3. 如果遇到文件结尾，那就无法继续调用 next() 方法了，这时可以直接将数组中的最小元素输出并移除，数组也跟着变小了。再进行下一轮循环。当数组空了，说明所有的文件都处理完了，算法就可以结束了。<img src="https://user-gold-cdn.xitu.io/2019/1/17/168599428898c463?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#alt=#alt=" alt> 值得注意的是，数组中永远不会存在同一个文件的两个元素，如此才保证了数组的长度不会超过输入文件的数量，同时它也不会把没有结尾的文件挤出数组导致漏排序的问题。</p>
<p><a name="0ac6e5c6"></a></p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>需要特别注意的是 Java 内置了二分查找算法在使用上比较精巧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Collections &#123;</span><br><span class="line">  ...</span><br><span class="line">  public static &lt;T&gt; int binarySearch(List&lt;T&gt; list, T key) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (found) &#123;</span><br><span class="line">      return index;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return -(insertIndex+1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果 key 可以在 list 中找到，那就直接返回相应的位置。如果找不到，它会返回负数，还不是简单的 -1，这个负数指明了插入的位置，也就是说在这个位置插入 key，数组将可以继续保持有序。</p>
<p>比如 binarySearch 返回了 index=-1，那么 insertIndex 就是 -(index+1)，也就是 0，插入点在数组开头。如果返回了 index=-size-1，那么 insertIndex 就是 size，是数组末尾。其它负数会插入数组中间。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/17/16859943cc887c0c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#alt=#alt=" alt></p>
<p><a name="ef74daa2"></a></p>
<h2 id="输入文件类"><a href="#输入文件类" class="headerlink" title="输入文件类"></a>输入文件类</h2><p>对于每一个输入文件都会创建一个 MergeSource 对象，它提供了 hasNext() 和 next() 方法用于判断和获取下一个元素。注意输入文件是有序的，下一个元素就是当前输入文件最小的元素。 hasNext() 方法负责读取下一行并缓存在 cachedLine 变量中，调用 next() 方法将 cachedLine 变量转换成整数并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class MergeSource implements Closeable &#123;</span><br><span class="line">	private BufferedReader reader;</span><br><span class="line">	private String cachedLine;</span><br><span class="line">	private String filename;</span><br><span class="line"></span><br><span class="line">	public MergeSource(String filename) &#123;</span><br><span class="line">		this.filename = filename;</span><br><span class="line">		try &#123;</span><br><span class="line">            FileReader fr = new FileReader(filename);</span><br><span class="line">			this.reader = new BufferedReader(fr);</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean hasNext() &#123;</span><br><span class="line">		String line;</span><br><span class="line">		try &#123;</span><br><span class="line">			line = this.reader.readLine();</span><br><span class="line">			if (line == null || line.isEmpty()) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			this.cachedLine = line.trim();</span><br><span class="line">			return true;</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int next() &#123;</span><br><span class="line">		if (this.cachedLine == null) &#123;</span><br><span class="line">			if (!hasNext()) &#123;</span><br><span class="line">				throw new IllegalStateException(&quot;no content&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int num = Integer.parseInt(this.cachedLine);</span><br><span class="line">		this.cachedLine = null;</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void close() throws IOException &#123;</span><br><span class="line">		this.reader.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="c3bdef97"></a></p>
<h2 id="内存有序数组元素类"><a href="#内存有序数组元素类" class="headerlink" title="内存有序数组元素类"></a>内存有序数组元素类</h2><p>在排序前先把这个数组准备好，将每个输入文件的最小元素放入数组，并排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Bin implements Comparable&lt;Bin&gt; &#123;</span><br><span class="line">	int num;</span><br><span class="line">	MergeSource source;</span><br><span class="line"></span><br><span class="line">	Bin(MergeSource source, int num) &#123;</span><br><span class="line">		this.source = source;</span><br><span class="line">		this.num = num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int compareTo(Bin o) &#123;</span><br><span class="line">		return this.num - o.num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Bin&gt; prepare() &#123;</span><br><span class="line">  	List&lt;Bin&gt; bins = new ArrayList&lt;&gt;();</span><br><span class="line">	for (MergeSource source : sources) &#123;</span><br><span class="line">		Bin newBin = new Bin(source, source.next());</span><br><span class="line">		bins.add(newBin);</span><br><span class="line">	&#125;</span><br><span class="line">    Collections.sort(bins);</span><br><span class="line">    return bins;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="e045cb99"></a></p>
<h2 id="输出文件类"><a href="#输出文件类" class="headerlink" title="输出文件类"></a>输出文件类</h2><p>关闭输出文件时注意要先 flush()，避免丢失 PrintWriter 中缓冲的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class MergeOut implements Closeable &#123;</span><br><span class="line">	private PrintWriter writer;</span><br><span class="line"></span><br><span class="line">	public MergeOut(String filename) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">            FileOutputStream out = new FileOutputStream(filename);</span><br><span class="line">			this.writer = new PrintWriter(out);</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void write(Bin bin) &#123;</span><br><span class="line">		writer.println(bin.num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void close() throws IOException &#123;</span><br><span class="line">		writer.flush();</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="13e490ba"></a></p>
<h2 id="准备输入文件的内容"><a href="#准备输入文件的内容" class="headerlink" title="准备输入文件的内容"></a>准备输入文件的内容</h2><p>下面我们来生成一系列输入文件，每个输入文件中包含一堆随机整数。一共生成 n 个文件，每个文件的整数数量在 minEntries 到 minEntries 之间。返回所有输入文件的文件名列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; generateFiles(int n, int minEntries, int maxEntries) &#123;</span><br><span class="line">	List&lt;String&gt; files = new ArrayList&lt;&gt;();</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		String filename = &quot;input-&quot; + i + &quot;.txt&quot;;</span><br><span class="line">		PrintWriter writer;</span><br><span class="line">		try &#123;</span><br><span class="line">			writer = new PrintWriter(new FileOutputStream(filename));</span><br><span class="line">            ThreadLocalRandom rand = ThreadLocalRandom.current();</span><br><span class="line">			int entries = rand.nextInt(minEntries, maxEntries);</span><br><span class="line">			List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();</span><br><span class="line">			for (int k = 0; k &lt; entries; k++) &#123;</span><br><span class="line">				int num = rand.nextInt(10000000);</span><br><span class="line">				nums.add(num);</span><br><span class="line">			&#125;</span><br><span class="line">			Collections.sort(nums);</span><br><span class="line">			for (int num : nums) &#123;</span><br><span class="line">				writer.println(num);</span><br><span class="line">			&#125;</span><br><span class="line">			writer.flush();</span><br><span class="line">			writer.close();</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		files.add(filename);</span><br><span class="line">	&#125;</span><br><span class="line">	return files;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="4772f735"></a></p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>万事俱备，只欠东风。将上面的类都准备好之后，排序算法很简单，代码量非常少。对照上面算法思路来理解下面的算法就很容易了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void sort() &#123;</span><br><span class="line">	List&lt;Bin&gt; bins = prepare();</span><br><span class="line">	while (true) &#123;</span><br><span class="line">        // 取数组中最小的元素</span><br><span class="line">		MergeSource current = bins.get(0).source;</span><br><span class="line">		if (current.hasNext()) &#123;</span><br><span class="line">            // 从输入文件中取出下一个元素</span><br><span class="line">			Bin newBin = new Bin(current, current.next());</span><br><span class="line">            // 二分查找，也就是和数组中已有元素进行比较</span><br><span class="line">			int index = Collections.binarySearch(bins, newBin);</span><br><span class="line">			if (index == 0) &#123;</span><br><span class="line">                // 算法思路情况1</span><br><span class="line">				this.out.write(newBin);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">                // 算法思路情况2</span><br><span class="line">				if (index &lt; 0) &#123;</span><br><span class="line">					index = -(index+1）;</span><br><span class="line">				&#125;</span><br><span class="line">				bins.add(index, newBin);</span><br><span class="line">				Bin minBin = bins.remove(0);</span><br><span class="line">				this.out.write(minBin);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">            // 算法思路情况3:遇到文件尾</span><br><span class="line">			Bin minBin = bins.remove(0);</span><br><span class="line">			this.out.write(minBin);</span><br><span class="line">			if (bins.isEmpty()) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="9705bbf6"></a></p>
<h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><p>读者可以直接将下面的代码拷贝粘贴到 IDE 中运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">package leetcode;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.Closeable;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line">public class DiskMergeSort implements Closeable &#123;</span><br><span class="line"></span><br><span class="line">	public static List&lt;String&gt; generateFiles(int n, int minEntries, int maxEntries) &#123;</span><br><span class="line">		List&lt;String&gt; files = new ArrayList&lt;&gt;();</span><br><span class="line">		for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			String filename = &quot;input-&quot; + i + &quot;.txt&quot;;</span><br><span class="line">			PrintWriter writer;</span><br><span class="line">			try &#123;</span><br><span class="line">				writer = new PrintWriter(new FileOutputStream(filename));</span><br><span class="line">				int entries = ThreadLocalRandom.current().nextInt(minEntries, maxEntries);</span><br><span class="line">				List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();</span><br><span class="line">				for (int k = 0; k &lt; entries; k++) &#123;</span><br><span class="line">					int num = ThreadLocalRandom.current().nextInt(10000000);</span><br><span class="line">					nums.add(num);</span><br><span class="line">				&#125;</span><br><span class="line">				Collections.sort(nums);</span><br><span class="line">				for (int num : nums) &#123;</span><br><span class="line">					writer.println(num);</span><br><span class="line">				&#125;</span><br><span class="line">				writer.close();</span><br><span class="line">			&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			files.add(filename);</span><br><span class="line">		&#125;</span><br><span class="line">		return files;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private List&lt;MergeSource&gt; sources;</span><br><span class="line">	private MergeOut out;</span><br><span class="line"></span><br><span class="line">	public DiskMergeSort(List&lt;String&gt; files, String outFilename) &#123;</span><br><span class="line">		this.sources = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String filename : files) &#123;</span><br><span class="line">			this.sources.add(new MergeSource(filename));</span><br><span class="line">		&#125;</span><br><span class="line">		this.out = new MergeOut(outFilename);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static class MergeOut implements Closeable &#123;</span><br><span class="line">		private PrintWriter writer;</span><br><span class="line"></span><br><span class="line">		public MergeOut(String filename) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				this.writer = new PrintWriter(new FileOutputStream(filename));</span><br><span class="line">			&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void write(Bin bin) &#123;</span><br><span class="line">			writer.println(bin.num);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void close() throws IOException &#123;</span><br><span class="line">			writer.flush();</span><br><span class="line">			writer.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static class MergeSource implements Closeable &#123;</span><br><span class="line">		private BufferedReader reader;</span><br><span class="line">		private String cachedLine;</span><br><span class="line"></span><br><span class="line">		public MergeSource(String filename) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				FileReader fr = new FileReader(filename);</span><br><span class="line">				this.reader = new BufferedReader(fr);</span><br><span class="line">			&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public boolean hasNext() &#123;</span><br><span class="line">			String line;</span><br><span class="line">			try &#123;</span><br><span class="line">				line = this.reader.readLine();</span><br><span class="line">				if (line == null || line.isEmpty()) &#123;</span><br><span class="line">					return false;</span><br><span class="line">				&#125;</span><br><span class="line">				this.cachedLine = line.trim();</span><br><span class="line">				return true;</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public int next() &#123;</span><br><span class="line">			if (this.cachedLine == null) &#123;</span><br><span class="line">				if (!hasNext()) &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;no content&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			int num = Integer.parseInt(this.cachedLine);</span><br><span class="line">			this.cachedLine = null;</span><br><span class="line">			return num;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void close() throws IOException &#123;</span><br><span class="line">			this.reader.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static class Bin implements Comparable&lt;Bin&gt; &#123;</span><br><span class="line">		int num;</span><br><span class="line">		MergeSource source;</span><br><span class="line"></span><br><span class="line">		Bin(MergeSource source, int num) &#123;</span><br><span class="line">			this.source = source;</span><br><span class="line">			this.num = num;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public int compareTo(Bin o) &#123;</span><br><span class="line">			return this.num - o.num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public List&lt;Bin&gt; prepare() &#123;</span><br><span class="line">		List&lt;Bin&gt; bins = new ArrayList&lt;&gt;();</span><br><span class="line">		for (MergeSource source : sources) &#123;</span><br><span class="line">			Bin newBin = new Bin(source, source.next());</span><br><span class="line">			bins.add(newBin);</span><br><span class="line">		&#125;</span><br><span class="line">		Collections.sort(bins);</span><br><span class="line">		return bins;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void sort() &#123;</span><br><span class="line">		List&lt;Bin&gt; bins = prepare();</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			MergeSource current = bins.get(0).source;</span><br><span class="line">			if (current.hasNext()) &#123;</span><br><span class="line">				Bin newBin = new Bin(current, current.next());</span><br><span class="line">				int index = Collections.binarySearch(bins, newBin);</span><br><span class="line">				if (index == 0 || index == -1) &#123;</span><br><span class="line">					this.out.write(newBin);</span><br><span class="line">					if (index == -1) &#123;</span><br><span class="line">						throw new IllegalStateException(&quot;impossible&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					if (index &lt; 0) &#123;</span><br><span class="line">						index = -index - 1;</span><br><span class="line">					&#125;</span><br><span class="line">					bins.add(index, newBin);</span><br><span class="line">					Bin minBin = bins.remove(0);</span><br><span class="line">					this.out.write(minBin);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				Bin minBin = bins.remove(0);</span><br><span class="line">				this.out.write(minBin);</span><br><span class="line">				if (bins.isEmpty()) &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void close() throws IOException &#123;</span><br><span class="line">		for (MergeSource source : sources) &#123;</span><br><span class="line">			source.close();</span><br><span class="line">		&#125;</span><br><span class="line">		this.out.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		List&lt;String&gt; inputs = DiskMergeSort.generateFiles(100, 10000, 20000);</span><br><span class="line">		// 运行多次看算法耗时</span><br><span class="line">		for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">			DiskMergeSort sorter = new DiskMergeSort(inputs, &quot;output.txt&quot;);</span><br><span class="line">			long start = System.currentTimeMillis();</span><br><span class="line">			sorter.sort();</span><br><span class="line">			long duration = System.currentTimeMillis() - start;</span><br><span class="line">			System.out.printf(&quot;%dms\n&quot;, duration);</span><br><span class="line">			sorter.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>本算法还有一个小缺陷，那就是如果输入文件数量非常多，那么内存中的数组就会特别大，对数组的插入删除操作肯定会很耗时，这时可以考虑使用 TreeSet 来代替数组，读者们可以自行尝试一下。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/17/16859951b20ebd48?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#alt=#alt=" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/yuque/跟着动画来学习 TCP 三次握手和四次挥手/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/yuque/跟着动画来学习 TCP 三次握手和四次挥手/" itemprop="url">跟着动画来学习 TCP 三次握手和四次挥手</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-22T11:31:31+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.im/post/5b29d2c4e51d4558b80b1d8c" target="_blank" rel="noopener">https://juejin.im/post/5b29d2c4e51d4558b80b1d8c</a></p>
</blockquote>
<p>TCP 三次握手和四次挥手的问题在面试中是最为常见的考点之一。很多读者都知道三次和四次，但是如果问深入一点，他们往往都无法作出准确回答。</p>
<p>本篇尝试使用动画来对这个知识点进行讲解，期望读者们可以更加简单地地理解 TCP 交互的本质。</p>
<p><a name="e518c6a4"></a></p>
<h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><p>TCP 三次握手就好比两个人在街上隔着 50 米看见了对方，但是因为雾霾等原因不能 100% 确认，所以要通过招手的方式相互确定对方是否认识自己。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/gif/99434/1548127912493-b6ded71c-8a9e-4eab-8756-1f98b471b716.gif#align=left&display=inline&height=900&originHeight=900&originWidth=720&size=0&width=720" alt></p>
<p>张三首先向李四招手 (<strong>syn</strong>)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑 (<strong>ack</strong>)。张三看到李四微笑后确认了李四成功辨认出了自己 (进入 <strong>estalished</strong> 状态)。</p>
<p>但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手 (<strong>syn</strong>)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑 (<strong>ack</strong>)，李四看到对方的微笑后确认了张三就是在向自己打招呼 (进入 <strong>established</strong> 状态)。</p>
<p>于是两人加快步伐，走到了一起，相互拥抱。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/gif/99434/1548127912466-816c90f7-7ec9-4502-8578-2fd3beca8131.gif#align=left&display=inline&height=398&originHeight=480&originWidth=900&size=0&width=746" alt></p>
<p>我们看到这个过程中一共是四个动作，张三招手 – 李四点头微笑 – 李四招手 – 张三点头微笑。其中李四连续进行了 2 个动作，先是点头微笑 (回复对方)，然后再次招手 (寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑 (<strong>syn+ack</strong>)。于是四个动作就简化成了三个动作，张三招手 – 李四点头微笑并招手 – 张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。</p>
<p>我们看到有两个中间状态，<strong>syn_sent</strong> 和 <strong>syn_rcvd</strong>，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的点头微笑。<strong>syn_sent</strong> 是主动打开方的「半打开」状态，<strong>syn_rcvd</strong> 是被动打开方的「半打开」状态。客户端是主动打开方，服务器是被动打开方。</p>
<ul>
<li>syn_sent: syn package has been sent</li>
<li>syn_rcvd: syn package has been received</li>
</ul>
<p><a name="d03d6057"></a></p>
<h2 id="TCP-数据传输"><a href="#TCP-数据传输" class="headerlink" title="TCP 数据传输"></a>TCP 数据传输</h2><p>TCP 数据传输就是两个人隔空对话，差了一点距离，所以需要对方反复确认听见了自己的话。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/gif/99434/1548127912513-e410671a-076b-48a0-abf0-9da8e3fa7a77.gif#align=left&display=inline&height=900&originHeight=900&originWidth=640&size=0&width=640" alt></p>
<p>张三喊了一句话 (data)，李四听见了之后要向张三回复自己听见了 (ack)。</p>
<p>如果张三喊了一句，半天没听到李四回复，张三就认为自己的话被大风吹走了，李四没听见，所以需要重新喊话，这就是 tcp 重传。</p>
<p>也有可能是李四听到了张三的话，但是李四向张三的回复被大风吹走了，以至于张三没听见李四的回复。张三并不能判断究竟是自己的话被大风吹走了还是李四的回复被大风吹走了，张三也不用管，重传一下就是。</p>
<p>既然会重传，李四就有可能同一句话听见了两次，这就是「去重」。「重传」和「去重」工作操作系统的网络内核模块都已经帮我们处理好了，用户层是不用关心的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/gif/99434/1548127912461-52d8902c-0f8b-4fc0-ad15-d40e7bb79786.gif#align=left&display=inline&height=311&originHeight=400&originWidth=960&size=0&width=746" alt></p>
<p>张三可以向李四喊话，同样李四也可以向张三喊话，因为 tcp 链接是「双工的」，双方都可以主动发起数据传输。不过无论是哪方喊话，都需要收到对方的确认才能认为对方收到了自己的喊话。</p>
<p>张三可能是个高射炮，一说连说了八句话，这时候李四可以不用一句一句回复，而是连续听了这八句话之后，一起向对方回复说前面你说的八句话我都听见了，这就是批量 ack。但是张三也不能一次性说了太多话，李四的脑子短时间可能无法消化太多，两人之间需要有协商好的合适的发送和接受速率，这个就是「TCP 窗口大小」。</p>
<p>网络环境的数据交互同人类之间的对话还要复杂一些，它存在数据包乱序的现象。同一个来源发出来的不同数据包在「网际路由」上可能会走过不同的路径，最终达到同一个地方时，顺序就不一样了。操作系统的网络内核模块会负责对数据包进行排序，到用户层时顺序就已经完全一致了。</p>
<p><a name="6d1e120a"></a></p>
<h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>TCP 断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了 4 个动作，张三挥手 (fin)——李四伤感地微笑 (ack)——李四挥手 (fin)——张三伤感地微笑 (ack)。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/gif/99434/1548127912515-4f88e8e6-71fe-458e-9c1b-d31c1970fb75.gif#align=left&display=inline&height=900&originHeight=900&originWidth=720&size=0&width=720" alt></p>
<p>之所以中间的两个动作没有合并，是因为 tcp 存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，朝张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/gif/99434/1548127912481-5df7bcc4-382c-4b22-a9cd-c5e4549a6cf6.gif#align=left&display=inline&height=360&originHeight=360&originWidth=676&size=0&width=676" alt></p>
<p>上面有一个非常特殊的状态<code>time_wait</code>，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是 4 分钟，4 分钟后才会进入到 closed 状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。</p>
<p>它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续 4 分钟的<code>time_wait</code>状态，不能释放套接字资源 (端口)，就好比守寡期，这段时间内套接字资源(端口) 不得回收利用。</p>
<p>它的作用是重传最后一个 ack 报文，确保对方可以收到。因为如果对方没有收到 ack 的话，会重传 fin 报文，处于 time_wait 状态的套接字会立即向对方重发 ack 报文。</p>
<p>同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文 (因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上) 传过来时，都会被立即丢弃掉。4 分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。</p>
<p>4 分钟就是 2 个 MSL，每个 MSL 是 2 分钟。MSL 就是<code>maximium segment lifetime</code>——最长报文寿命。这个时间是由官方 RFC 协议规定的。至于为什么是 2 个 MSL 而不是 1 个 MSL，我还没有看到一个非常满意的解释。</p>
<p>四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从<code>fin_wait_1</code>状态直接进入到<code>time_wait</code>状态，跳过了<code>fin_wait_2</code>状态。</p>
<p><a name="25f9c7fa"></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TCP 状态转换是一个非常复杂的过程，本文仅对一些简单的基础知识点进行了类比讲解。关于 TCP 的更多知识还需要读者去搜寻相关技术文章进入深入学习。如果读者对 TCP 的基础知识掌握得比较牢固，高级的知识理解起来就不会太过于吃力。</p>
<p>关于 TCP 的更多文章，还请关注微信公众号「码洞」进行订阅，后续我会持续更新更多细节。</p>
<p>如果觉得本文写的质量还可以，就给我的掘金小册捧捧场吧</p>
<p><a href="https://juejin.im/book/5af56a3c518825426642e004" target="_blank" rel="noopener"><strong>深入理解 RPC</strong></a> <a href="https://juejin.im/book/5af56a3c518825426642e004" target="_blank" rel="noopener"><strong>深入理解 RPC</strong></a> <a href="https://juejin.im/book/5af56a3c518825426642e004" target="_blank" rel="noopener"><strong>深入理解 RPC</strong></a></p>
<p><a href="https://juejin.im/book/5af56a3c518825426642e004" target="_blank" rel="noopener"><strong>深入理解 RPC</strong></a> <a href="https://juejin.im/book/5af56a3c518825426642e004" target="_blank" rel="noopener"><strong>深入理解 RPC</strong></a> <a href="https://juejin.im/book/5af56a3c518825426642e004" target="_blank" rel="noopener"><strong>深入理解 RPC</strong></a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/yuque/Java8 新特性指导手册/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/yuque/Java8 新特性指导手册/" itemprop="url">Java8 新特性指导手册</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-22T11:30:52+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.im/post/5c3d7c8a51882525dd591ac7" target="_blank" rel="noopener">https://juejin.im/post/5c3d7c8a51882525dd591ac7</a></p>
</blockquote>
<blockquote>
<p>本教程翻译整理自 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwinterbe%2Fjava8-tutorial" target="_blank" rel="noopener">github.com/winterbe/ja…</a></p>
</blockquote>
<p><a name="cfeff30d"></a></p>
<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><ul>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#%E6%8E%A5%E5%8F%A3%E5%86%85%E5%85%81%E8%AE%B8%E6%B7%BB%E5%8A%A0%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">一、接口内允许添加默认实现的方法</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">二、Lambda 表达式</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-Functional-Interface" target="_blank" rel="noopener">三、函数式接口 Functional Interface</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#%E4%BE%BF%E6%8D%B7%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">四、便捷的引用类的构造器及方法</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Lambda-%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%8F%8A%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">五、Lambda 访问外部变量及接口默认方法</a><ul>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#%E8%AE%BF%E9%97%AE%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">5.1 访问局部变量</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">5.2 访问成员变量和静态变量</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">5.3 访问接口的默认方法</a></li>
</ul>
</li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#%E5%86%85%E7%BD%AE%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">六、内置的函数式接口</a><ul>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Predicate-%E6%96%AD%E8%A8%80" target="_blank" rel="noopener">6.1 Predicate 断言</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Function" target="_blank" rel="noopener">6.2 Function</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Supplier-%E7%94%9F%E4%BA%A7%E8%80%85" target="_blank" rel="noopener">6.3 Supplier 生产者</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Consumer-%E6%B6%88%E8%B4%B9%E8%80%85" target="_blank" rel="noopener">6.4 Consumer 消费者</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Comparator" target="_blank" rel="noopener">6.5 Comparator</a></li>
</ul>
</li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Optional" target="_blank" rel="noopener">七、Optional</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Stream-%E6%B5%81" target="_blank" rel="noopener">八、Streams 流</a><ul>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Filter-%E8%BF%87%E6%BB%A4" target="_blank" rel="noopener">8.1 Filter 过滤</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Sorted-%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">8.2 Sorted 排序</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Map-%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">8.3 Map 转换</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Match-%E5%8C%B9%E9%85%8D" target="_blank" rel="noopener">8.4 Match 匹配</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Count-%E8%AE%A1%E6%95%B0" target="_blank" rel="noopener">8.5 Count 计数</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Reduce" target="_blank" rel="noopener">8.6 Reduce</a></li>
</ul>
</li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Parallel-Streams-%E5%B9%B6%E8%A1%8C%E6%B5%81" target="_blank" rel="noopener">九、Parallel Streams 并行流</a><ul>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#%E9%A1%BA%E5%BA%8F%E6%B5%81%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">9.1 顺序流排序</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#%E5%B9%B6%E8%A1%8C%E6%B5%81%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">9.2 并行流排序</a></li>
</ul>
</li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Map-%E9%9B%86%E5%90%88" target="_blank" rel="noopener">十、Map 集合</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F-API" target="_blank" rel="noopener">十一、新的日期 API</a><ul>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Clock" target="_blank" rel="noopener">11.1 Clock</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Timezones-%E6%97%B6%E5%8C%BA" target="_blank" rel="noopener">11.2 Timezones 时区</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#LocalTime" target="_blank" rel="noopener">11.3 LocalTime</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#LocalDate" target="_blank" rel="noopener">11.4 LocalDate</a></li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#LocalDateTime" target="_blank" rel="noopener">11.4 LocalDateTime</a></li>
</ul>
</li>
<li><a href="https://souche.yuque.com/kun95/ynl730/ypoxo3/edit#Annotations-%E6%B3%A8%E8%A7%A3" target="_blank" rel="noopener">十二、Annotations 注解</a></li>
</ul>
<p>也希望学完本系列教程的小伙伴能够熟练掌握和应用 Java8 的各种特性，使其成为在工作中的一门利器。废话不多说，让我们一起开启 Java8 新特性之旅吧！</p>
<hr>
<p>★★★ <strong>如果此教程有帮助到你, 去小哈的 GitHub 帮忙 **Star</strong> 一下吧, 谢谢啦！** <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fweiwosuoai%2Fjava8_guide" target="_blank" rel="noopener">传送门</a> ★★★</p>
<hr>
<p><a name="90c0f18e"></a></p>
<h2 id="接口内允许添加默认实现的方法"><a href="#接口内允许添加默认实现的方法" class="headerlink" title="接口内允许添加默认实现的方法"></a>接口内允许添加默认实现的方法</h2><p>Java 8 允许我们通过 <code>default</code> 关键字对接口中定义的抽象方法提供一个默认的实现。</p>
<p>请看下面示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个公式接口</span><br><span class="line">interface Formula &#123;</span><br><span class="line">    // 计算</span><br><span class="line">    double calculate(int a);</span><br><span class="line"></span><br><span class="line">    // 求平方根</span><br><span class="line">    default double sqrt(int a) &#123;</span><br><span class="line">        return Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在上面这个接口中，我们除了定义了一个抽象方法 <code>calculate</code>，还定义了一个带有默认实现的方法 <code>sqrt</code>。 我们在实现这个接口时，可以只需要实现 <code>calculate</code> 方法，默认方法 <code>sqrt</code> 可以直接调用即可，也就是说我们可以不必强制实现 <code>sqrt</code> 方法。</p>
<blockquote>
<p>补充：通过 <code>default</code> 关键字这个新特性，可以非常方便地对之前的接口做拓展，而此接口的实现类不必做任何改动。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = new Formula() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double calculate(int a) &#123;</span><br><span class="line">        return sqrt(a * 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(100);     // 100.0</span><br><span class="line">formula.sqrt(16);           // 4.0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面通过匿名对象实现了 <code>Formula</code> 接口。但是即使是这样，我们为了完成一个 <code>sqrt(a * 100)</code> 简单计算，就写了 6 行代码，很是冗余。</p>
<p><a name="75bf3fb1"></a></p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>在学习 <code>Lambda</code> 表达式之前，我们先来看一段老版本的示例代码，其对一个含有字符串的集合进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String a, String b) &#123;</span><br><span class="line">        return b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>Collections</code> 工具类提供了静态方法 <code>sort</code> 方法，入参是一个 <code>List</code> 集合，和一个 <code>Comparator</code> 比较器，以便对给定的 <code>List</code> 集合进行 排序。上面的示例代码创建了一个匿名内部类作为入参，这种类似的操作在我们日常的工作中随处可见。</p>
<p>Java 8 中不再推荐这种写法，而是推荐使用 Lambda 表达：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    return b.compareTo(a);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>正如你看到的，上面这段代码变得简短很多而且易于阅读。但是我们还可以再精炼一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对于只包含一行方法的代码块，我们可以省略大括号，直接 <code>return</code> 关键代码即可。追求极致，我们还可以让它再短点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names.sort((a, b) -&gt; b.compareTo(a));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>List</code> 集合现在已经添加了 <code>sort</code> 方法。而且 Java 编译器能够根据<strong>类型推断机制</strong>判断出参数类型，这样，你连入参的类型都可以省略啦，怎么样，是不是感觉很强大呢！</p>
<p><a name="160243f4"></a></p>
<h2 id="函数式接口-Functional-Interface"><a href="#函数式接口-Functional-Interface" class="headerlink" title="函数式接口 Functional Interface"></a>函数式接口 Functional Interface</h2><p>抛出一个疑问：在我们书写一段 Lambda 表达式后（比如上一章节中匿名内部类的 Lambda 表达式缩写形式），Java 编译器是如何进行类型推断的，它又是怎么知道重写的哪个方法的？</p>
<p>需要说明的是，不是每个接口都可以缩写成 Lambda 表达式。只有那些函数式接口（Functional Interface）才能缩写成 Lambda 表示式。</p>
<p>那么什么是函数式接口（Functional Interface）呢？</p>
<p>所谓函数式接口（Functional Interface）就是只包含一个抽象方法的声明。针对该接口类型的所有 Lambda 表达式都会与这个抽象方法匹配。</p>
<blockquote>
<p>注意：你可能会有疑问，Java 8 中不是允许通过 defualt 关键字来为接口添加默认方法吗？那它算不算抽象方法呢？答案是：不算。因此，你可以毫无顾忌的添加默认方法，它并不违反函数式接口（Functional Interface）的定义。</p>
</blockquote>
<p>总结一下：只要接口中仅仅包含一个抽象方法，我们就可以将其改写为 Lambda 表达式。为了保证一个接口明确的被定义为一个函数式接口（Functional Interface），我们需要为该接口添加注解：<code>@FunctionalInterface</code>。这样，一旦你添加了第二个抽象方法，编译器会立刻抛出错误提示。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>示例代码 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class="line">System.out.println(converted);    // 123</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：上面的示例代码，即使去掉 <code>@FunctionalInterface</code> 也是好使的，它仅仅是一种约束而已。</p>
</blockquote>
<p><a name="62b92c2b"></a></p>
<h2 id="便捷的引用类的构造器及方法"><a href="#便捷的引用类的构造器及方法" class="headerlink" title="便捷的引用类的构造器及方法"></a>便捷的引用类的构造器及方法</h2><p>小伙伴们，还记得上一个章节这段示例代码么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class="line">System.out.println(converted);    // 123</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面这段代码，通过 Java 8 的新特性，进一步简化上面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class="line">System.out.println(converted);   // 123</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Java 8 中允许你通过 <code>::</code> 关键字来引用类的方法或构造器。上面的代码简单的示例了如何引用静态方法，当然，除了静态方法，我们还可以引用普通方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Something &#123;</span><br><span class="line">    String startsWith(String s) &#123;</span><br><span class="line">        return String.valueOf(s.charAt(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Something something = new Something();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(&quot;Java&quot;);</span><br><span class="line">System.out.println(converted);    // &quot;J&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>接下来，我们再来看看如何通过 <code>::</code> 关键字来引用类的构造器。首先，我们先来定义一个示例类，在类中声明两个构造器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后，我们再定义一个工厂接口，用来生成 <code>Person</code> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Person 工厂</span><br><span class="line">interface PersonFactory&lt;P extends Person&gt; &#123;</span><br><span class="line">    P create(String firstName, String lastName);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>::</code> 关键字来引用 <code>Person</code> 类的构造器，来代替手动去实现这个工厂接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 直接引用 Person 构造器</span><br><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::new;</span><br><span class="line">Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>Person::new</code> 这段代码，能够直接引用 <code>Person</code> 类的构造器。然后 Java 编译器能够根据上下文选中正确的构造器去实现 <code>PersonFactory.create</code> 方法。</p>
<p><a name="c81218bf"></a></p>
<h2 id="Lambda-访问外部变量及接口默认方法"><a href="#Lambda-访问外部变量及接口默认方法" class="headerlink" title="Lambda 访问外部变量及接口默认方法"></a>Lambda 访问外部变量及接口默认方法</h2><p>在本章节中，我们将会讨论如何在 lambda 表达式中访问外部变量（包括：局部变量，成员变量，静态变量，接口的默认方法.），它与匿名内部类访问外部变量很相似。</p>
<p><a name="c2e51379"></a></p>
<h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>在 Lambda 表达式中，我们可以访问外部的 <code>final</code> 类型变量，如下面的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 转换器</span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(2);     // 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>与匿名内部类不同的是，我们不必显式声明 <code>num</code> 变量为 <code>final</code> 类型，下面这段代码同样有效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(2);     // 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>但是 <code>num</code> 变量必须为隐式的 <code>final</code> 类型，何为隐式的 <code>final</code> 呢？就是说到编译期为止，<code>num</code> 对象是不能被改变的，如下面这段代码，就不能被编译通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = 3;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在 lambda 表达式内部改变 <code>num</code> 值同样编译不通过，需要注意, 比如下面的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; converter = (from) -&gt; &#123;</span><br><span class="line">	String value = String.valueOf(from + num);</span><br><span class="line">	num = 3;</span><br><span class="line">	return value;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="f0b07ba6"></a></p>
<h3 id="访问成员变量和静态变量"><a href="#访问成员变量和静态变量" class="headerlink" title="访问成员变量和静态变量"></a>访问成员变量和静态变量</h3><p>上一章节中，了解了如何在 Lambda 表达式中访问局部变量。与局部变量相比，在 Lambda 表达式中对成员变量和静态变量拥有读写权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">    interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">        T convert(F from);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Lambda4 &#123;</span><br><span class="line">        // 静态变量</span><br><span class="line">        static int outerStaticNum;</span><br><span class="line">        // 成员变量</span><br><span class="line">        int outerNum;</span><br><span class="line"></span><br><span class="line">        void testScopes() &#123;</span><br><span class="line">            Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">                // 对成员变量赋值</span><br><span class="line">                outerNum = 23;</span><br><span class="line">                return String.valueOf(from);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">                // 对静态变量赋值</span><br><span class="line">                outerStaticNum = 72;</span><br><span class="line">                return String.valueOf(from);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="e9841639"></a></p>
<h3 id="访问接口的默认方法"><a href="#访问接口的默认方法" class="headerlink" title="访问接口的默认方法"></a>访问接口的默认方法</h3><p>还记得第一章节中定义的那个 <code>Formula</code> (公式) 接口吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Formula &#123;</span><br><span class="line">	// 计算</span><br><span class="line">	double calculate(int a);</span><br><span class="line"></span><br><span class="line">	// 求平方根</span><br><span class="line">	default double sqrt(int a) &#123;</span><br><span class="line">		return Math.sqrt(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当时，我们在接口中定义了一个带有默认实现的 <code>sqrt</code> 求平方根方法，在匿名内部类中我们可以很方便的访问此方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = new Formula() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public double calculate(int a) &#123;</span><br><span class="line">		return sqrt(a * 100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>但是在 lambda 表达式中可不行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt(a * 100);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>带有默认实现的接口方法，是<strong>不能</strong>在 lambda 表达式中访问的，上面这段代码将无法被编译通过。</p>
<p><a name="f5de65ac"></a></p>
<h2 id="内置的函数式接口"><a href="#内置的函数式接口" class="headerlink" title="内置的函数式接口"></a>内置的函数式接口</h2><p>JDK 1.8 API 包含了很多内置的函数式接口。其中就包括我们在老版本中经常见到的 Comparator 和 Runnable，Java 8 为他们都添加了 <a href>FunctionalInterface </a>注解，以用来支持 Lambda 表达式。</p>
<p>值得一提的是，除了 Comparator 和 Runnable 外，还有一些新的函数式接口，它们很多都借鉴于知名的 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Fguava" target="_blank" rel="noopener">Google Guava</a> 库。</p>
<p>对于它们，即使你已经非常熟悉了，还是最好了解一下的：</p>
<p><a name="cca10afe"></a></p>
<h3 id="Predicate-断言"><a href="#Predicate-断言" class="headerlink" title="Predicate 断言"></a>Predicate 断言</h3><p><code>Predicate</code> 是一个可以指定入参类型，并返回 boolean 值的函数式接口。它内部提供了一些带有默认实现的方法，可以 被用来组合一个复杂的逻辑判断（<code>and</code>, <code>or</code>, <code>negate</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;</span><br><span class="line"></span><br><span class="line">predicate.test(&quot;foo&quot;);              // true</span><br><span class="line">predicate.negate().test(&quot;foo&quot;);     // false</span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="Function"></a></p>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><code>Function</code> 函数式接口的作用是，我们可以为其提供一个原料，他给生产一个最终的产品。通过它提供的默认方法，组合, 链行处理 (<code>compose</code>, <code>andThen</code>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line"></span><br><span class="line">backToString.apply(&quot;123&quot;);     // &quot;123&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="8dda89e0"></a></p>
<h3 id="Supplier-生产者"><a href="#Supplier-生产者" class="headerlink" title="Supplier 生产者"></a>Supplier 生产者</h3><p><code>Supplier</code> 与 <code>Function</code> 不同，它不接受入参，直接为我们生产一个指定的结果，有点像生产者模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::new;</span><br><span class="line">personSupplier.get();   // new Person</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="37c62d93"></a></p>
<h3 id="Consumer-消费者"><a href="#Consumer-消费者" class="headerlink" title="Consumer 消费者"></a>Consumer 消费者</h3><p>对于 <code>Consumer</code>，我们需要提供入参，用来被消费，如下面这段示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);</span><br><span class="line">greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="Comparator"></a></p>
<h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p><code>Comparator</code> 在 Java 8 之前是使用比较普遍的。Java 8 中除了将其升级成了函数式接口，还为它拓展了一些默认方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);</span><br><span class="line">Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             // &gt; 0</span><br><span class="line">comparator.reversed().compare(p1, p2);  // &lt; 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="Optional"></a></p>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>首先，<code>Optional</code> 它不是一个函数式接口，设计它的目的是为了防止空指针异常（<code>NullPointerException</code>），要知道在 Java 编程中， 空指针异常可是臭名昭著的。</p>
<p>让我们来快速了解一下 <code>Optional</code> 要如何使用！你可以将 <code>Optional</code> 看做是包装对象（可能是 <code>null</code>, 也有可能非 <code>null</code>）的容器。当你定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，你就可以考虑用 <code>Optional</code> 来包装它，这也是在 Java 8 被推荐使用的做法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);</span><br><span class="line"></span><br><span class="line">optional.isPresent();           // true</span><br><span class="line">optional.get();                 // &quot;bam&quot;</span><br><span class="line">optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;</span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="6d24bd9f"></a></p>
<h2 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h2><p>这一章节，我们开始步入学习 <code>Stream</code> 流。</p>
<p><em>什么是 <code>Stream</code> 流？</em></p>
<p>简单来说，我们可以使用 <code>java.util.Stream</code> 对一个包含一个或多个元素的集合做各种操作。这些操作可能是 <em>中间操作</em> 亦或是 _终端操作_。 终端操作会返回一个结果，而中间操作会返回一个 <code>Stream</code> 流。</p>
<p>需要注意的是，你只能对实现了 <code>java.util.Collection</code> 接口的类做流的操作。</p>
<blockquote>
<p><code>Map</code> 不支持 <code>Stream</code> 流。</p>
</blockquote>
<p><code>Stream</code> 流支持同步执行，也支持并发执行。</p>
<p>让我们开始步入学习的旅程吧！Go !</p>
<p><a name="35f21c77"></a></p>
<h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter 过滤"></a>Filter 过滤</h3><p>首先，我们创建一个 <code>List</code> 集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(&quot;ddd2&quot;);</span><br><span class="line">stringCollection.add(&quot;aaa2&quot;);</span><br><span class="line">stringCollection.add(&quot;bbb1&quot;);</span><br><span class="line">stringCollection.add(&quot;aaa1&quot;);</span><br><span class="line">stringCollection.add(&quot;bbb3&quot;);</span><br><span class="line">stringCollection.add(&quot;ccc&quot;);</span><br><span class="line">stringCollection.add(&quot;bbb2&quot;);</span><br><span class="line">stringCollection.add(&quot;ddd1&quot;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>Filter</code> 的入参是一个 <code>Predicate</code>, 上面已经说到，<code>Predicate</code> 是一个断言的中间操作，它能够帮我们筛选出我们需要的集合元素。它的返参同样 是一个 <code>Stream</code> 流，我们可以通过 <code>foreach</code> 终端操作，来打印被筛选的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">// &quot;aaa2&quot;, &quot;aaa1&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>foreach</code> 是一个终端操作，它的返参是 <code>void</code>, 我们无法对其再次进行流操作。</p>
</blockquote>
<p><a name="4ac3d996"></a></p>
<h3 id="Sorted-排序"><a href="#Sorted-排序" class="headerlink" title="Sorted 排序"></a>Sorted 排序</h3><p><code>Sorted</code> 同样是一个中间操作，它的返参是一个 <code>Stream</code> 流。另外，我们可以传入一个 <code>Comparator</code> 用来自定义排序，如果不传，则使用默认的排序规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">// &quot;aaa1&quot;, &quot;aaa2&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>需要注意，<code>sorted</code> 不会对 <code>stringCollection</code> 做出任何改变，<code>stringCollection</code> 还是原有的那些个元素，且顺序不变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(stringCollection);</span><br><span class="line">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="78e2f144"></a></p>
<h3 id="Map-转换"><a href="#Map-转换" class="headerlink" title="Map 转换"></a>Map 转换</h3><p>中间操作 <code>Map</code> 能够帮助我们将 <code>List</code> 中的每一个元素做功能处理。例如下面的示例，通过 <code>map</code> 我们将每一个 <code>string</code> 转成大写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>另外，我们还可以做对象之间的转换，业务中比较常用的是将 <code>DO</code>（数据库对象） 转换成 <code>BO</code>（业务对象） 。</p>
<p><a name="b1e9fab6"></a></p>
<h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match 匹配"></a>Match 匹配</h3><p>顾名思义，<code>match</code> 用来做匹配操作，它的返回值是一个 <code>boolean</code> 类型。通过 <code>match</code>, 我们可以方便的验证一个 <code>list</code> 中是否存在某个类型的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true</span><br><span class="line">boolean anyStartsWithA =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);      // true</span><br><span class="line"></span><br><span class="line">// 验证 list 中 string 是否都是以 a 开头的</span><br><span class="line">boolean allStartsWithA =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      // false</span><br><span class="line"></span><br><span class="line">// 验证 list 中 string 是否都不是以 z 开头的,</span><br><span class="line">boolean noneStartsWithZ =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      // true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="d46dce25"></a></p>
<h3 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count 计数"></a>Count 计数</h3><p><code>count</code> 是一个终端操作，它能够统计 <code>stream</code> 流中的元素总数，返回值是 <code>long</code> 类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 先对 list 中字符串开头为 b 进行过滤，让后统计数量</span><br><span class="line">long startsWithB =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(&quot;b&quot;))</span><br><span class="line">        .count();</span><br><span class="line"></span><br><span class="line">System.out.println(startsWithB);    // 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="Reduce"></a></p>
<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p><code>Reduce</code> 中文翻译为：_减少、缩小_。通过入参的 <code>Function</code>，我们能够将 <code>list</code> 归约成一个值。它的返回类型是 <code>Optional</code> 类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="b2264d65"></a></p>
<h2 id="Parallel-Streams-并行流"><a href="#Parallel-Streams-并行流" class="headerlink" title="Parallel-Streams 并行流"></a>Parallel-Streams 并行流</h2><p>前面章节我们说过，<code>stream</code> 流是支持<strong>顺序</strong>和<strong>并行</strong>的。顺序流操作是单线程操作，而并行流是通过多线程来处理的，能够充分利用物理机 多核 CPU 的优势，同时处理速度更快。</p>
<p>首先，我们创建一个包含 1000000 UUID list 集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int max = 1000000;</span><br><span class="line">List&lt;String&gt; values = new ArrayList&lt;&gt;(max);</span><br><span class="line">for (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>分别通过顺序流和并行流，对这个 list 进行排序，测算耗时:</p>
<p><a name="111628cc"></a></p>
<h3 id="顺序流排序"><a href="#顺序流排序" class="headerlink" title="顺序流排序"></a>顺序流排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 纳秒</span><br><span class="line">long t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">long count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line">long t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">// 纳秒转微秒</span><br><span class="line">long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(&quot;顺序流排序耗时: %d ms&quot;, millis));</span><br><span class="line"></span><br><span class="line">// 顺序流排序耗时: 899 ms</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="eb499c12"></a></p>
<h3 id="并行流排序"><a href="#并行流排序" class="headerlink" title="并行流排序"></a>并行流排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 纳秒</span><br><span class="line">long t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">long count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line">long t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">// 纳秒转微秒</span><br><span class="line">long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(&quot;并行流排序耗时: %d ms&quot;, millis));</span><br><span class="line"></span><br><span class="line">// 并行流排序耗时: 472 ms</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>正如你所见，同样的逻辑处理，通过并行流，我们的性能提升了近 <strong>50%</strong>。完成这一切，我们需要做的仅仅是将 <code>stream</code> 改成了 <code>parallelStream</code>。</p>
<p><a name="8321d67b"></a></p>
<h2 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a>Map 集合</h2><p>前面已经提到过 <code>Map</code> 是不支持 <code>Stream</code> 流的，因为 <code>Map</code> 接口并没有像 <code>Collection</code> 接口那样，定义了 <code>stream()</code> 方法。但是，我们可以对其 <code>key</code>, <code>values</code>, <code>entry</code> 使用 流操作，如 <code>map.keySet().stream()</code>, <code>map.values().stream()</code> 和 <code>map.entrySet().stream()</code>.</p>
<p>另外, JDK 8 中对 <code>map</code> 提供了一些其他新特性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    // 与老版不同的是，putIfAbent() 方法在 put 之前，</span><br><span class="line">    // 会判断 key 是否已经存在，存在则直接返回 value, 否则 put, 再返回 value</span><br><span class="line">    map.putIfAbsent(i, &quot;val&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// forEach 可以很方便地对 map 进行遍历操作</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(value));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>除了上面的 <code>putIfAbsent()</code> 和 <code>forEach()</code> 外，我们还可以很方便地对某个 <code>key</code> 的值做相关操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// computeIfPresent(), 当 key 存在时，才会做相关处理</span><br><span class="line">// 如下：对 key 为 3 的值，内部会先判断值是否存在，存在，则做 value + key 的拼接操作</span><br><span class="line">map.computeIfPresent(3, (num, val) -&gt; val + num);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line"></span><br><span class="line">// 先判断 key 为 9 的元素是否存在，存在，则做删除操作</span><br><span class="line">map.computeIfPresent(9, (num, val) -&gt; null);</span><br><span class="line">map.containsKey(9);     // false</span><br><span class="line"></span><br><span class="line">// computeIfAbsent(), 当 key 不存在时，才会做相关处理</span><br><span class="line">// 如下：先判断 key 为 23 的元素是否存在，不存在，则添加</span><br><span class="line">map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);</span><br><span class="line">map.containsKey(23);    // true</span><br><span class="line"></span><br><span class="line">// 先判断 key 为 3 的元素是否存在，存在，则不做任何处理</span><br><span class="line">map.computeIfAbsent(3, num -&gt; &quot;bam&quot;);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>关于删除操作，JDK 8 中提供了能够新的 <code>remove()</code> API:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map.remove(3, &quot;val3&quot;);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line"></span><br><span class="line">map.remove(3, &quot;val33&quot;);</span><br><span class="line">map.get(3);             // null</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如上代码，只有当给定的 <code>key</code> 和 <code>value</code> 完全匹配时，才会执行删除操作。</p>
<p>关于添加方法，JDK 8 中提供了带有默认值的 <code>getOrDefault()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 若 key 42 不存在，则返回 not found</span><br><span class="line">map.getOrDefault(42, &quot;not found&quot;);  // not found</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对于 <code>value</code> 的合并操作也变得更加简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// merge 方法，会先判断进行合并的 key 是否存在，不存在，则会添加元素</span><br><span class="line">map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(9);             // val9</span><br><span class="line"></span><br><span class="line">// 若 key 的元素存在，则对 value 执行拼接操作</span><br><span class="line">map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(9);             // val9concat</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="df70aa39"></a></p>
<h2 id="新的日期-API"><a href="#新的日期-API" class="headerlink" title="新的日期 API"></a>新的日期 API</h2><p>Java 8 中在包 <code>java.time</code> 下添加了新的日期 API. 它和 <a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.joda.org%2Fjoda-time%2F" target="_blank" rel="noopener">Joda-Time</a> 库相似，但又不完全相同。接下来，我会通过一些示例代码介绍一下新 API 中 最关键的特性：</p>
<p><a name="Clock"></a></p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p><code>Clock</code> 提供对当前日期和时间的访问。我们可以利用它来替代 <code>System.currentTimeMillis()</code> 方法。另外，通过 <code>clock.instant()</code> 能够获取一个 <code>instant</code> 实例， 此实例能够方便地转换成老版本中的 <code>java.util.Date</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line">long millis = clock.millis();</span><br><span class="line"></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);   // 老版本 java.util.Date</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="4791e622"></a></p>
<h3 id="Timezones-时区"><a href="#Timezones-时区" class="headerlink" title="Timezones 时区"></a>Timezones 时区</h3><p><code>ZoneId</code> 代表时区类。通过静态工厂方法方便地获取它，入参我们可以传入某个时区编码。另外，时区类还定义了一个偏移量，用来在当前时刻或某时间 与目标时区时间之间进行转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line">// prints all available timezone ids</span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);</span><br><span class="line">ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line">// ZoneRules[currentStandardOffset=+01:00]</span><br><span class="line">// ZoneRules[currentStandardOffset=-03:00]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="LocalTime"></a></p>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p><code>LocalTime</code> 表示一个没有指定时区的时间类，例如，<code>10 p.m</code>. 或者 <code>17：30:15</code>，下面示例代码中，将会使用上面创建的 时区对象创建两个 <code>LocalTime</code>。然后我们会比较两个时间，并计算它们之间的小时和分钟的不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line"></span><br><span class="line">System.out.println(now1.isBefore(now2));  // false</span><br><span class="line"></span><br><span class="line">long hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line">long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);       // -3</span><br><span class="line">System.out.println(minutesBetween);     // -239</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>LocalTime</code> 提供多个静态工厂方法，目的是为了简化对时间对象实例的创建和操作，包括对时间字符串进行解析的操作等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(23, 59, 59);</span><br><span class="line">System.out.println(late);       // 23:59:59</span><br><span class="line"></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   // 13:37</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="LocalDate"></a></p>
<h2 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h2><p><code>LocalDate</code> 是一个日期对象，例如：<code>2014-03-11</code>。它和 <code>LocalTime</code> 一样是个 <code>final</code> 类型对象。下面的例子演示了如何通过加减日，月，年等来计算一个新的日期。</p>
<blockquote>
<p><code>LocalDate</code>, <code>LocalTime</code>, 因为是 <code>final</code> 类型的对象，每一次操作都会返回一个新的时间对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">// 今天加一天</span><br><span class="line">LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);</span><br><span class="line">// 明天减两天</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(2);</span><br><span class="line"></span><br><span class="line">// 2014 年七月的第四天</span><br><span class="line">LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);    // 星期五</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>也可以直接解析日期字符串，生成 <code>LocalDate</code> 实例。（和 <code>LocalTime</code> 操作一样简单）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);</span><br><span class="line">System.out.println(xmas);   // 2014-12-24</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="LocalDateTime"></a></p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p><code>LocalDateTime</code> 是一个<strong>日期 - 时间</strong>对象。你也可以将其看成是 <code>LocalDate</code> 和 <code>LocalTime</code> 的结合体。操作上，也大致相同。</p>
<blockquote>
<p><code>LocalDateTime</code> 同样是一个 <code>final</code> 类型对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      // 星期三</span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          // 十二月</span><br><span class="line"></span><br><span class="line">// 获取改时间是该天中的第几分钟</span><br><span class="line">long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    // 1439</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果再加上的时区信息，<code>LocalDateTime</code> 还能够被转换成 <code>Instance</code> 实例。<code>Instance</code> 能够被转换成老版本中 <code>java.util.Date</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>格式化 <code>LocalDateTime</code> 对象就和格式化 LocalDate 或者 LocalTime 一样。除了使用预定义的格式以外，也可以自定义格式化输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);</span><br><span class="line"></span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     // Nov 03, 2014 - 07:13</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：和 <code>java.text.NumberFormat</code> 不同，新的 <code>DateTimeFormatter</code> 类是 <code>final</code> 类型的，同时也是线程安全的。更多细节请查看<a href="https://link.juejin.im/?target=http%3A%2F%2Fdownload.java.net%2Fjdk8%2Fdocs%2Fapi%2Fjava%2Ftime%2Fformat%2FDateTimeFormatter.html" target="_blank" rel="noopener">这里</a></p>
</blockquote>
<p><a name="44fc421c"></a></p>
<h2 id="Annotations-注解"><a href="#Annotations-注解" class="headerlink" title="Annotations 注解"></a>Annotations 注解</h2><p>在 Java 8 中，注解是可以重复的。让我通过下面的示例代码，来看看到底是咋回事。</p>
<p>首先，我们定义一个包装注解，里面包含了一个有着实际注解的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repeatable(Hints.class)</span><br><span class="line">@interface Hint &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Java 8 中，通过 <code>@Repeatable</code>，允许我们对同一个类使用多重注解：</p>
<p>第一种形态：使用注解容器（老方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>第二种形态：使用可重复注解（新方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Hint(&quot;hint1&quot;)</span><br><span class="line">@Hint(&quot;hint2&quot;)</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>使用第二种形态，Java 编译器能够在内部自动对 <code>@Hint</code> 进行设置。这对于需要通过反射来读取注解信息时，是非常重要的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hint hint = Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   // null</span><br><span class="line"></span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  // 2</span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          // 2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>尽管我们绝对不会在 <code>Person</code> 类上声明 <code>@Hints</code> 注解，但是它的信息仍然是可以通过 <code>getAnnotation(Hints.class)</code> 来读取的。 并且，<code>getAnnotationsByType</code> 方法会更方便，因为它赋予了所有 <code>@Hints</code> 注解标注的方法直接的访问权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line">@interface MyAnnotation &#123;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="433531fd"></a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Java 8 新特性的编程指南到此就告一段落了。当然，还有很多内容需要进一步研究和说明。这就需要靠读者您来对 JDK 8 进一步探究了， 例如：<code>Arrays.parallelSort</code>, <code>StampedLock</code> 和 <code>CompletableFuture</code> 等等，我这里也仅是起到抛砖引玉的作用而已。</p>
<p>最后，我希望这个教程能够对您有所帮助，也希望您阅读愉快。</p>
<p><a name="b8c89356"></a></p>
<h2 id="小哈的微信公众号"><a href="#小哈的微信公众号" class="headerlink" title="小哈的微信公众号"></a>小哈的微信公众号</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/yuque/码农的运维指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="临安的风">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/yuque/码农的运维指南/" itemprop="url">码农的运维指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-22T11:29:01+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="a3bf94c1"></a></p>
<h4 id="查询时间段内的日志"><a href="#查询时间段内的日志" class="headerlink" title="查询时间段内的日志"></a>查询时间段内的日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/20180905:06:20:00/,/20180905:06:30:00/p'</span>  tomcat_stdout.log-20180905</span><br><span class="line">sed -n <span class="string">'/20180905:02:10/,/20180905:02:20/p'</span>  tomcat_stdout.log-20180905</span><br></pre></td></tr></table></figure>

<p><a name="7c1c8e68"></a></p>
<h4 id="查询文件的后10行"><a href="#查询文件的后10行" class="headerlink" title="查询文件的后10行"></a>查询文件的后10行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 10 tomcat_stdout.log-20180905</span><br></pre></td></tr></table></figure>

<p><a name="9d60e7b5"></a></p>
<h4 id="查询文件的前10行"><a href="#查询文件的前10行" class="headerlink" title="查询文件的前10行"></a>查询文件的前10行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 10 tomcat_stdout.log-20180905</span><br></pre></td></tr></table></figure>

<p><a name="db8ad796"></a></p>
<h4 id="在指定目录下查询是否有指定名称的文件"><a href="#在指定目录下查询是否有指定名称的文件" class="headerlink" title="在指定目录下查询是否有指定名称的文件"></a>在指定目录下查询是否有指定名称的文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /logs/ -name <span class="string">'abc.log'</span></span><br></pre></td></tr></table></figure>

<p><a name="c8c0d895"></a></p>
<h4 id="一次搜索多个gz文件中的内容"><a href="#一次搜索多个gz文件中的内容" class="headerlink" title="一次搜索多个gz文件中的内容"></a>一次搜索多个gz文件中的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zgrep 1537354997562_xRi0 mybatis*2018-09-19.log*|grep che168_1004076</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">临安的风</p>
              <p class="site-description motion-element" itemprop="description">网络资源搬运工 Java Spring 面试 数据库 算法 zk dubbo 分布式 redis React Flutter anything</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">都来自于互联网</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
